0	0
Sensor	0
Coverage	0
Robot	0
Swarms	0
Using	0
Local	0
Sensing	0
0	0
without	0
Metric	0
Information	0
0	0
Rattanachai	0
Ramaithitima,	0
Michael	0
Whitzer,	0
Subhrajit	0
Bhattacharya	0
and	0
Vijay	0
Kumar	0
*	0
0	0
Abstract	0
We	0
consider	0
the	0
problem	0
of	0
deploying	0
a	0
swarm	0
0	0
of	0
mobile	0
robots	0
into	0
an	0
unknown	0
environment	0
for	0
attaining	0
0	0
complete	0
sensor	0
coverage	0
of	0
the	0
environment.	0
The	0
robots	0
0	0
have	0
limited	0
and	0
noisy	0
sensing	0
capabilities	0
and	0
no	0
metric	0
0	0
or	0
global	0
information	0
available	0
to	0
them.	0
Using	0
tools	0
from	0
0	0
algebraic	0
topology,	0
we	0
formally	0
describe	0
the	0
sensor	0
coverage	0
0	0
as	0
a	0
simplicial	0
complex,	0
deploy	0
robots	0
through	0
the	0
complex	0
0	0
using	0
bearing-based	0
local	0
controllers,	0
and	0
attain	0
coverage	0
while	0
0	0
identifying	0
and	0
removing	0
sensor	0
redundancies.	0
Despite	0
the	0
0	0
highly	0
limited	0
sensing	0
capabilities	0
and	0
complete	0
lack	0
of	0
global	0
0	0
localization	0
and	0
metric	0
information,	0
we	0
demonstrate	0
that	0
the	0
0	0
proposed	0
algorithm	0
is	0
complete,	0
always	0
terminates	0
in	0
a	0
finite-	0
0	0
sized	0
environment,	0
is	0
guaranteed	0
to	0
attain	0
complete	0
coverage	0
0	0
and	0
is	0
robust	0
to	0
sensor	0
failures.	0
The	0
algorithm	0
presented	0
in	0
0	0
this	0
paper	0
was	0
demonstrated	0
through	0
simulation	0
and	0
proves	0
to	0
0	0
effectively	0
cover	0
and	0
explore	0
unknown	0
indoor	0
environments.	0
0	0
I.	0
INTRODUCTION	0
0	0
A.	0
Motivation	0
and	0
Related	0
Work	0
0	0
Sensor	0
coverage	0
of	0
indoor	0
environments	0
using	0
teams	0
of	0
0	0
mobile	0
robots	0
is	0
a	0
well-studied	0
problem	0
in	0
robotics.	0
Cover-	0
0	0
age	0
path	0
planning	0
refers	0
to	0
the	0
task	0
of	0
visiting	0
every	0
point	0
0	0
(or	0
within	0
a	0
certain	0
distance	0
of	0
every	0
point)	0
in	0
a	0
given	0
0	0
environment	0
as	0
has	0
been	0
addressed	0
in	0
[1],	0
[2],	0
[3].	0
In	0
the	0
0	0
present	0
context	0
however,	0
we	0
focus	0
on	0
attaining	0
coverage	0
0	0
by	0
a	0
sensor	0
network,	0
which	0
is	0
the	0
task	0
of	0
deployment	0
and	0
0	0
distribution	0
of	0
a	0
team	0
of	0
robots	0
such	0
that	0
they	0
attain	0
and	0
0	0
maintain	0
constant	0
sensory	0
coverage	0
of	0
every	0
point	0
in	0
the	0
en-	0
0	0
vironment.	0
In	0
presence	0
of	0
limited	0
number	0
of	0
robots	0
this	0
prob-	0
0	0
lem	0
has	0
often	0
been	0
handled	0
using	0
Voronoi	0
partition	0
of	0
the	0
0	0
environment	0
and	0
minimization	0
of	0
a	0
coverage	0
functional	0
[4],	0
0	0
[5].	0
However	0
such	0
approaches	0
invariably	0
rely	0
on	0
a	0
global	0
0	0
and	0
centralized	0
localization	0
capability	0
for	0
each	0
robot	0
(for	0
0	0
example,	0
using	0
GPS).	0
Complete	0
sensor	0
coverage	0
of	0
indoor	0
0	0
environments	0
using	0
swarm	0
of	0
robots	0
have	0
been	0
studied	0
in	0
[6],	0
0	0
[7],	0
where	0
the	0
known	0
world	0
is	0
modeled	0
as	0
a	0
graph,	0
robots	0
0	0
are	0
assumed	0
to	0
have	0
global	0
localization	0
and	0
can	0
be	0
made	0
0	0
to	0
navigate	0
independently	0
from	0
one	0
location	0
to	0
another	0
in	0
a	0
0	0
global	0
coordinate	0
frame.	0
In	0
almost	0
all	0
these	0
lines	0
of	0
research,	0
0	0
global	0
localization	0
of	0
the	0
robots,	0
a	0
priori	0
knowledge	0
of	0
the	0
0	0
environment	0
(obstacle	0
configurations),	0
availability	0
of	0
metric	0
0	0
information	0
and	0
ability	0
to	0
control	0
the	0
robots	0
from	0
one	0
point	0
0	0
in	0
the	0
environment	0
to	0
another	0
have	0
been	0
assumed.	0
0	0
Biologically	0
inspired	0
multi-robot	0
coverage	0
algorithms	0
0	0
have	0
also	0
been	0
proposed	0
[8],	0
[1],	0
which	0
are	0
most	0
often	0
dis-	0
0	0
tributed	0
and	0
the	0
robots	0
rely	0
on	0
local	0
sensing	0
only.	0
Similar	0
lo-	0
0	0
*University	0
of	0
Pennsylvania.	0
[ramar,mwhitzer,subhrabh,	0
0	0
kumar]@seas.upenn.edu.	0
The	0
authors	0
gratefully	0
acknowledge	0
the	0
0	0
support	0
of	0
AFOSR	0
grant	0
FA9550-10-1-0567,	0
ONR	0
grants	0
N00014-07-1-	0
0	0
0829,	0
N00014-09-1-1051,	0
and	0
N00014-09-1-103.	0
0	0
cal	0
communication-based	0
algorithms	0
for	0
robot	0
swarms	0
have	0
0	0
been	0
used	0
to	0
construct	0
various	0
shapes	0
[9]	0
in	0
an	0
environment.	0
0	0
However,	0
such	0
behavior-based	0
algorithms	0
come	0
with	0
very	0
0	0
limited	0
theoretical	0
guarantee.	0
Likewise,	0
distributed	0
coverage	0
0	0
algorithm	0
with	0
no	0
global	0
localization	0
have	0
been	0
studied	0
in	0
0	0
[10].	0
But	0
the	0
notion	0
of	0
coverage	0
being	0
purely	0
based	0
on	0
a	0
0	0
graph	0
gives	0
limited	0
to	0
no	0
guarantee	0
on	0
the	0
attainment	0
of	0
sen-	0
0	0
sor	0
coverage	0
or	0
the	0
optimality.	0
Furthermore	0
such	0
approaches	0
0	0
inherently	0
assume	0
availability	0
of	0
some	0
metric	0
information.	0
0	0
In	0
recent	0
years	0
coverage	0
by	0
sensor	0
network	0
has	0
been	0
0	0
studied	0
more	0
formally	0
using	0
simplicial	0
complex	0
and	0
ho-	0
0	0
mological	0
tools	0
from	0
algebraic	0
topology	0
[11],	0
[12].	0
Such	0
0	0
approaches	0
are	0
completely	0
topological	0
and	0
require	0
little	0
to	0
0	0
no	0
metric	0
information.	0
In	0
general,	0
homology	0
computation	0
has	0
0	0
been	0
extremely	0
useful	0
in	0
detecting	0
holes	0
in	0
sensor	0
network	0
0	0
coverage.	0
While	0
some	0
progress	0
has	0
indeed	0
been	0
made	0
in	0
0	0
controlling	0
the	0
network	0
so	0
as	0
to	0
mend	0
the	0
holes	0
in	0
sensor	0
0	0
coverage	0
[13],	0
[14],	0
all	0
these	0
methods	0
work	0
only	0
in	0
obstacle-	0
0	0
free	0
environments	0
and	0
require	0
some	0
localization	0
of	0
the	0
robots	0
0	0
for	0
being	0
able	0
to	0
control	0
them.	0
0	0
Closely	0
related	0
to	0
our	0
work	0
is	0
the	0
literature	0
of	0
explo-	0
0	0
ration	0
of	0
unknown	0
environment	0
without	0
global	0
localization.	0
0	0
Simultaneous	0
Localization	0
and	0
Mapping	0
(SLAM)	0
[15]	0
re-	0
0	0
quires	0
a	0
robot	0
(or	0
a	0
group	0
of	0
robots)	0
to	0
navigate	0
in	0
an	0
0	0
environment	0
acquiring	0
range	0
measurements	0
(to	0
obstacles),	0
0	0
and	0
then	0
stitch	0
the	0
collected	0
data	0
to	0
construct	0
a	0
complete	0
map	0
0	0
of	0
the	0
environment.	0
This	0
process	0
is	0
however	0
quite	0
complex	0
0	0
and	0
requires	0
significant	0
amount	0
of	0
computation.	0
We	0
assume	0
0	0
limited	0
computation	0
power	0
on	0
each	0
robot,	0
and	0
having	0
a	0
0	0
swarm	0
of	0
roots	0
at	0
our	0
disposal	0
and	0
sensor	0
coverage	0
of	0
the	0
0	0
environment	0
being	0
the	0
primary	0
objective,	0
we	0
do	0
not	0
perform	0
0	0
a	0
full-blown	0
SLAM.	0
The	0
robots	0
sensor	0
capabilities	0
are	0
also	0
0	0
limited	0
compared	0
to	0
what	0
is	0
typically	0
required	0
by	0
SLAM.	0
0	0
A	0
similar	0
research	0
conducted	0
by	0
Lee,	0
et	0
al.	0
[16]	0
studies	0
0	0
the	0
problem	0
of	0
maximization	0
of	0
coverage	0
area	0
with	0
limited	0
0	0
number	0
of	0
robots	0
equipped	0
with	0
limited	0
local	0
sensors.	0
How-	0
0	0
ever,	0
our	0
approach	0
is	0
different,	0
and	0
performs	0
better,	0
in	0
at	0
least	0
0	0
three	0
aspects:	0
First,	0
our	0
proposed	0
method	0
is	0
robust	0
to	0
robot	0
0	0
failure	0
and	0
can	0
start	0
from	0
an	0
arbitrary	0
configuration	0
of	0
the	0
0	0
robots,	0
since	0
the	0
computations	0
at	0
every	0
iteration	0
are	0
purely	0
0	0
based	0
on	0
the	0
current	0
state	0
only.	0
Second,	0
our	0
approach	0
of	0
0	0
pushing	0
the	0
robots	0
through	0
the	0
graph	0
in	0
order	0
to	0
expand	0
0	0
the	0
frontier	0
to	0
the	0
unknown	0
regions,	0
instead	0
of	0
navigate	0
a	0
0	0
robot	0
from	0
the	0
source	0
to	0
the	0
frontier,	0
has	0
a	0
lower	0
execution	0
0	0
time	0
at	0
each	0
cycle,	0
and	0
does	0
not	0
require	0
any	0
restriction	0
on	0
the	0
0	0
minimum	0
distance	0
between	0
two	0
neighboring	0
robots.	0
Lastly,	0
0	0
our	0
proposed	0
algorithm	0
does	0
not	0
require	0
the	0
workspace	0
to	0
be	0
0	0
2015	0
IEEE	0
International	0
Conference	0
on	0
Robotics	0
and	0
Automation	0
(ICRA)	0
0	0
Washington	0
State	0
Convention	0
Center	0
0	0
Seattle,	0
Washington,	0
May	0
26-30,	0
2015	0
0	0
978-1-4799-6922-7/15/$31.00	0
2015	0
IEEE	0
0	0
3408	0
0	0
simply-connected,	0
as	0
we	0
demonstrate	0
through	0
experimental	0
0	0
results	0
in	0
complex,	0
indoor	0
environments	0
with	0
obstacles.	0
0	0
We	0
adopt	0
a	0
simplicial	0
complex	0
representation	0
(in	0
par-	0
0	0
ticular,	0
a	0
Rips	0
complex)	0
as	0
the	0
richer	0
and	0
more	0
formal	0
0	0
description	0
of	0
the	0
sensor	0
coverage,	0
without	0
using	0
metric	0
0	0
information,	0
to	0
solve	0
the	0
problem	0
of	0
deployment	0
of	0
robots	0
0	0
in	0
an	0
unknown	0
environment	0
without	0
global	0
localization.	0
0	0
The	0
robots	0
only	0
have	0
onboard	0
sensors	0
to	0
measure	0
bearings	0
0	0
to	0
neighboring	0
robots	0
in	0
their	0
local	0
coordinates	0
and	0
touch	0
0	0
sensors	0
for	0
collision	0
avoidance.	0
Such	0
limited	0
sensing	0
data	0
0	0
essentially	0
allows	0
deployment	0
of	0
robots	0
in	0
a	0
dark	0
room,	0
with	0
0	0
the	0
robots	0
using	0
their	0
camera	0
to	0
identify	0
their	0
neighbors	0
by	0
0	0
illuminated	0
(LED)	0
markers	0
on	0
each	0
other.	0
Since	0
our	0
approach	0
0	0
is	0
fundamentally	0
topological,	0
the	0
proposed	0
method	0
is	0
highly	0
0	0
robust	0
to	0
sensor	0
noise.	0
We	0
attain	0
complete	0
sensor	0
coverage	0
0	0
of	0
the	0
entire	0
finite	0
environment	0
assuming	0
sufficient	0
number	0
0	0
of	0
available	0
robots,	0
along	0
with	0
guarantees	0
on	0
coverage,	0
0	0
exploration	0
and	0
a	0
notion	0
of	0
local	0
optimality.	0
0	0
B.	0
Problem	0
Description	0
0	0
We	0
consider	0
the	0
problem	0
of	0
efficiently	0
exploring	0
an	0
un-	0
0	0
known	0
indoor	0
environment	0
with	0
a	0
rapidly	0
expanding	0
swarm	0
0	0
of	0
robots	0
with	0
limited	0
and	0
noisy	0
local	0
sensing	0
with	0
no	0
global	0
0	0
localization	0
or	0
sensing	0
capabilities.	0
In	0
particular,	0
the	0
only	0
0	0
sensory	0
capabilities	0
that	0
we	0
assume	0
on	0
each	0
robot	0
are	0
those	0
0	0
of	0
an	0
omni-directional	0
camera	0
with	0
a	0
limited	0
radial	0
range	0
0	0
of	0
vision	0
and	0
a	0
touch	0
sensor	0
to	0
detect	0
contact/collision	0
with	0
0	0
obstacles	0
and	0
other	0
robots.	0
We	0
call	0
the	0
disk	0
around	0
a	0
robot,	0
0	0
representing	0
a	0
sensing	0
radius	0
of	0
the	0
omni-directional	0
camera,	0
0	0
the	0
robots	0
disk	0
of	0
visibility,	0
within	0
which	0
the	0
bearing	0
to	0
0	0
the	0
neighboring	0
robots	0
and	0
their	0
identities	0
can	0
be	0
detected.	0
0	0
However,	0
the	0
camera	0
does	0
not	0
provide	0
a	0
range	0
measurement	0
0	0
due	0
to	0
projection	0
of	0
the	0
spacial	0
world	0
on	0
to	0
the	0
camera	0
plane.	0
0	0
Thus,	0
obstacles	0
are	0
detected	0
through	0
touch	0
sensors	0
near	0
the	0
0	0
base	0
of	0
the	0
robots,	0
and	0
cannot	0
be	0
detected	0
using	0
the	0
camera.	0
0	0
The	0
robots	0
can	0
also	0
communicate	0
with	0
each	0
other	0
and	0
with	0
0	0
a	0
central	0
router	0
through	0
wireless	0
communication.	0
The	0
robots	0
0	0
are	0
assumed	0
to	0
holonomic	0
(i.e.	0
can	0
be	0
driven	0
in	0
arbitrary	0
0	0
direction).	0
We	0
assume	0
that	0
there	0
are	0
sufficiently	0
large	0
number	0
0	0
of	0
robots	0
available,	0
which	0
are	0
being	0
deployed	0
from	0
one	0
or	0
0	0
multiple	0
sources	0
(e.g.	0
entrance	0
to	0
an	0
environment).	0
0	0
The	0
contribution	0
of	0
this	0
paper	0
is	0
to	0
design	0
a	0
distributable	0
0	0
control	0
algorithm	0
for	0
the	0
robots	0
such	0
that	0
they	0
deploy	0
them-	0
0	0
selves	0
to	0
attain	0
hole-less	0
coverage	0
of	0
the	0
entire	0
environment	0
0	0
using	0
their	0
disks	0
of	0
visibility.	0
That	0
means,	0
at	0
least	0
one	0
0	0
robot	0
should	0
be	0
able	0
to	0
see	0
each	0
and	0
every	0
point	0
in	0
the	0
0	0
environment	0
after	0
the	0
coverage	0
is	0
attained.	0
However,	0
the	0
only	0
0	0
information	0
that	0
they	0
have	0
are	0
the	0
bearing	0
to	0
their	0
neighbors	0
0	0
in	0
their	0
respective	0
local	0
coordinate	0
frames	0
and	0
a	0
directional	0
0	0
touch	0
information	0
with	0
obstacles.	0
This	0
means	0
that	0
there	0
is	0
0	0
absolutely	0
no	0
metric	0
information	0
available.	0
0	0
II.	0
PRELIMINARIES	0
0	0
A.	0
Notations	0
0	0
We	0
denote	0
by	0
W	0
R	0
2	0
the	0
obstacle-free	0
region	0
where	0
the	0
0	0
robots	0
are	0
being	0
deployed	0
and	0
the	0
sensor	0
coverage	0
of	0
which	0
0	0
needs	0
to	0
be	0
attained.	0
If	0
there	0
are	0
n	0
robots	0
deployed	0
in	0
W	0
,	0
0	0
we	0
assign	0
IDs	0
to	0
them,	0
1,	0
2,	0
,	0
n,	0
and	0
represent	0
their	0
joint	0
0	0
configuration	0
by	0
X	0
=	0
[x	0
1	0
,	0
x	0
2	0
,	0
,	0
x	0
n	0
],	0
x	0
i	0
W	0
.	0
0	0
Hole	0
0	0
Fig.	0
1.	0
Illustration	0
of	0
a	0
swarm	0
of	0
robots	0
entering	0
an	0
environment	0
and	0
0	0
attaining	0
coverage.	0
The	0
hole	0
shown	0
on	0
the	0
right	0
figure	0
is	0
something	0
we	0
0	0
would	0
like	0
to	0
avoid.	0
0	0
A	0
robot,	0
i,	0
can	0
measure	0
the	0
bearing	0
to	0
a	0
neighbor,	0
j	0
N	0
i	0
,	0
0	0
in	0
its	0
local	0
coordinates,	0
where	0
N	0
i	0
=	0
{j	0
|	0
x	0
i	0
x	0
j	0
r	0
v	0
}	0
are	0
0	0
the	0
neighbors	0
of	0
i.	0
We	0
call	0
this	0
measurement	0
i	0
0	0
j	0
[,	0
).	0
0	0
If	0
it	0
measures	0
the	0
bearing	0
to	0
another	0
robot,	0
k	0
as	0
i	0
0	0
k	0
,	0
then	0
we	0
0	0
define	0
i	0
0	0
jk	0
=	0
0	0
0	0
(	0
i	0
0	0
k	0
i	0
0	0
j	0
)	0
mod	0
2	0
0	0
0	0
0	0
i.e.,	0
the	0
bearing	0
0	0
to	0
k	0
relative	0
to	0
the	0
bearing	0
to	0
j	0
(and	0
the	0
angle	0
converted	0
to	0
0	0
a	0
value	0
in	0
[,	0
)).	0
0	0
B.	0
VietorisRips	0
Complex	0
of	0
Camera	0
Sensing	0
Footprints	0
0	0
We	0
do	0
not	0
assume	0
that	0
the	0
robots	0
can	0
localize	0
themselves	0
0	0
and	0
the	0
only	0
way	0
of	0
sensing/identifying	0
neighbors	0
is	0
by	0
0	0
using	0
the	0
camera.	0
Thus,	0
if	0
the	0
disks	0
of	0
visibility	0
of	0
two	0
0	0
robots	0
merely	0
overlap,	0
there	0
is	0
no	0
way	0
of	0
detecting	0
that	0
fact	0
0	0
(Figure	0
2(a)).	0
We	0
need	0
to	0
use	0
a	0
stronger	0
notion	0
of	0
overlap	0
0	0
two	0
robots	0
know	0
that	0
their	0
disks	0
of	0
visibility	0
overlap	0
if	0
0	0
and	0
only	0
if	0
they	0
are	0
in	0
each	0
others	0
disks	0
of	0
visibility	0
and	0
0	0
their	0
line	0
of	0
sight	0
is	0
not	0
blocked	0
(Figure	0
2(b)).	0
0	0
1	0
0	0
2	0
0	0
(a)	0
Robots	0
cant	0
see	0
each	0
other,	0
0	0
and	0
hence	0
have	0
no	0
way	0
of	0
de-	0
0	0
tecting	0
that	0
their	0
disks	0
of	0
visi-	0
0	0
bility	0
overlap.	0
0	0
1	0
0	0
2	0
0	0
(b)	0
Robots	0
can	0
see	0
each	0
other,	0
and	0
0	0
hence	0
know	0
that	0
their	0
disks	0
of	0
vis-	0
0	0
ibility	0
overlap.	0
Visibility	0
is	0
repre-	0
0	0
sented	0
by	0
the	0
dotted	0
magenta	0
line.	0
0	0
Fig.	0
2.	0
Detection	0
of	0
overlap	0
of	0
disks	0
of	0
visibility	0
using	0
only	0
local	0
visibility-	0
0	0
based	0
sensing.	0
0	0
We	0
can	0
thus	0
consider	0
a	0
simplicial	0
complex	0
[17]	0
repre-	0
0	0
sentation	0
of	0
the	0
free	0
space	0
that	0
the	0
camera	0
footprints	0
cover.	0
0	0
The	0
description	0
of	0
the	0
abstract	0
simplicial	0
complex	0
goes	0
as	0
0	0
follows	0
(Figure	0
3):	0
We	0
add	0
one	0
0-simplex	0
to	0
the	0
complex	0
for	0
0	0
every	0
deployed	0
robot	0
in	0
the	0
environment	0
(the	0
0-simplices	0
are	0
0	0
identified	0
by	0
the	0
robot	0
IDs).	0
A	0
1-simplex	0
is	0
added	0
between	0
0	0
two	0
0-simplices	0
if	0
the	0
corresponding	0
robots	0
are	0
in	0
each	0
0	0
others	0
disk	0
of	0
visibility	0
(i.e.,	0
are	0
within	0
distance	0
of	0
r	0
v	0
from	0
0	0
each	0
other)	0
and	0
can	0
see	0
each	0
other.	0
A	0
2-simplex	0
is	0
added	0
0	0
to	0
the	0
complex	0
for	0
every	0
3-tuple	0
of	0
robots	0
that	0
can	0
all	0
see	0
0	0
each	0
other	0
(and	0
hence	0
their	0
disks	0
of	0
visibility	0
has	0
a	0
non-	0
0	0
empty	0
intersection).	0
We	0
do	0
not	0
construct	0
any	0
3	0
or	0
higher	0
0	0
dimensional	0
simplices	0
since	0
on	0
a	0
planar	0
environment	0
with	0
0	0
obstacles,	0
we	0
are	0
only	0
concerned	0
with	0
the	0
H	0
1	0
homology.	0
0	0
1	0
0	0
2	0
0	0
3	0
0	0
4	0
0	0
5	0
0	0
9	0
0	0
6	0
0	0
7	0
0	0
8	0
0	0
1	0
0	0
2	0
0	0
3	0
0	0
4	0
0	0
5	0
0	0
6	0
0	0
7	0
0	0
8	0
0	0
9	0
0	0
Fig.	0
3.	0
Nine	0
robots,	0
their	0
disks	0
of	0
visibility	0
and	0
the	0
corresponding	0
abstract	0
0	0
simplicial	0
complex,	0
Rr	0
v	0
.	0
0	0
3409	0
0	0
This	0
simplicial	0
complex	0
is,	0
by	0
definition,	0
the	0
Vietoris-	0
0	0
Rips	0
complex	0
[11]	0
(or	0
simply	0
the	0
Rips	0
complex)	0
on	0
the	0
0	0
set	0
of	0
robots	0
(constructed	0
up	0
to	0
dimension	0
2	0
i.e.,	0
we	0
0	0
do	0
not	0
construct	0
the	0
3	0
and	0
higher	0
simplices),	0
with	0
distance	0
0	0
between	0
pairs	0
of	0
robots	0
being	0
the	0
length	0
of	0
the	0
unobstructed	0
0	0
line	0
segment	0
connecting	0
them	0
(and	0
a	0
distance	0
being	0
infinity	0
0	0
if	0
such	0
a	0
line	0
segment	0
does	0
not	0
exist	0
due	0
to	0
presence	0
of	0
0	0
obstacles)	0
and	0
the	0
parameter	0
for	0
the	0
Rips	0
complex	0
being	0
r	0
v	0
.	0
0	0
For	0
a	0
particular	0
joint	0
configuration	0
of	0
the	0
robots,	0
X,	0
we	0
call	0
0	0
this	0
simplicial	0
complex	0
R	0
rv	0
(X).	0
We	0
denote	0
the	0
0-simplices	0
0	0
in	0
R	0
rv	0
(X)	0
by	0
the	0
corresponding	0
robot	0
ID	0
(e.g.,	0
i),	0
the	0
0	0
1-simplices	0
by	0
pairs	0
of	0
IDs	0
of	0
the	0
robots	0
that	0
make	0
them	0
0	0
up	0
(e.g.,	0
{i,	0
j}),	0
and	0
2-simplices	0
by	0
three	0
tuples	0
(such	0
as	0
0	0
{i,	0
j,	0
k}).	0
Formally,	0
R	0
rv	0
(X)	0
is	0
a	0
chain	0
complex	0
[17]	0
and	0
0	0
constitutes	0
of	0
a	0
sequence	0
of	0
modules	0
(or	0
vector	0
spaces)	0
0	0
along	0
with	0
boundary	0
maps:	0
0	0
0	0
0	0
0	0
C	0
2	0
0	0
2	0
0	0
C	0
1	0
0	0
1	0
0	0
C	0
0	0
0	0
0	0
0	0
0,	0
0	0
where	0
C	0
d	0
is	0
an	0
abstract	0
module	0
(or	0
vector	0
space)	0
generated	0
0	0
(or	0
spanned)	0
by	0
the	0
d-dimensional	0
simplices.	0
Whenever	0
0	0
the	0
robots	0
configuration,	0
X,	0
is	0
obvious	0
or	0
implied	0
by	0
the	0
0	0
context,	0
we	0
will	0
write	0
R	0
rv	0
to	0
denote	0
the	0
corresponding	0
0	0
complex	0
for	0
simplicity.	0
In	0
Section	0
III-A	0
we	0
will	0
identify	0
two	0
0	0
sub-complexes	0
of	0
R	0
rv	0
,	0
namely	0
the	0
frontier	0
subcomplex,	0
F,	0
0	0
and	0
obstacle	0
subcomplex,	0
O,	0
which	0
together	0
constitute	0
the	0
0	0
fence	0
subcomplex	0
[11],	0
K	0
=	0
F	0
O.	0
0	0
It	0
is	0
important	0
to	0
note	0
that	0
R	0
rv	0
can	0
be	0
constructed	0
with	0
0	0
local	0
visibility	0
information	0
only,	0
as	0
described	0
earlier,	0
and	0
0	0
does	0
not	0
require	0
the	0
entire	0
configuration,	0
X,	0
of	0
the	0
robots	0
0	0
to	0
be	0
known	0
in	0
a	0
centralized	0
manner.	0
Furthermore,	0
as	0
will	0
0	0
be	0
evident	0
in	0
the	0
next	0
section,	0
we	0
do	0
not	0
need	0
to	0
construct	0
0	0
the	0
entire	0
simplicial	0
complex	0
in	0
a	0
centralized	0
fashion	0
for	0
0	0
most	0
of	0
the	0
algorithmic	0
components.	0
Its	0
only	0
when	0
we	0
0	0
compute	0
generators	0
for	0
the	0
relative	0
homology	0
H	0
2	0
(R	0
rv	0
,	0
K),	0
0	0
for	0
optimization	0
purposes,	0
that	0
we	0
will	0
need	0
to	0
store	0
R	0
rv	0
in	0
0	0
a	0
centralized	0
manner.	0
0	0
C.	0
Contact/Touch	0
Sensing	0
Model	0
0	0
As	0
mentioned	0
earlier,	0
the	0
only	0
sensors	0
on	0
board	0
each	0
0	0
robot	0
are	0
the	0
omnidirectional	0
camera	0
and	0
a	0
collection	0
of	0
0	0
touch/contact	0
sensors	0
at	0
the	0
base	0
of	0
the	0
robots.	0
The	0
camera	0
0	0
is	0
used	0
to	0
measure	0
bearing	0
with	0
other	0
robots	0
inside	0
the	0
0	0
disk	0
of	0
visibility	0
and	0
is	0
incapable	0
of	0
measuring	0
range.	0
The	0
0	0
touch	0
sensors	0
are	0
binary	0
sensors,	0
and	0
are	0
triggered	0
when	0
in	0
0	0
contact	0
with	0
an	0
obstacle/wall	0
or	0
another	0
robot	0
(Figure	0
4).	0
0	0
The	0
presence	0
of	0
multiple	0
touch	0
sensors	0
(N	0
T	0
counts	0
of	0
them)	0
0	0
at	0
the	0
base	0
also	0
provides	0
a	0
rough	0
estimate	0
of	0
direction	0
of	0
0	0
contact	0
(within	0
an	0
error	0
of	0
=	0
0	0
N	0
T	0
0	0
when	0
a	0
single	0
touch	0
0	0
sensor	0
is	0
activated).	0
0	0
Fig.	0
4.	0
The	0
touch/contact	0
sensors	0
(gray	0
protrusions)	0
at	0
the	0
base	0
of	0
a	0
robot	0
0	0
(red).	0
Contact	0
with	0
an	0
obstacle	0
or	0
another	0
robot	0
triggers	0
one	0
or	0
more	0
touch	0
0	0
sensors	0
providing	0
a	0
rough	0
estimate	0
of	0
the	0
direction	0
of	0
contact.	0
0	0
D.	0
Local	0
Bearing-Based	0
Controller	0
0	0
The	0
robots	0
are	0
controlled	0
using	0
the	0
bearing-based	0
visual	0
0	0
homing	0
controller	0
presented	0
in	0
[18].	0
This	0
controller	0
utilizes	0
0	0
a	0
gradient	0
decent	0
approach	0
where	0
desired	0
bearing	0
angles	0
to	0
0	0
landmarks	0
are	0
used	0
to	0
drive	0
robots.	0
The	0
distances	0
between	0
a	0
0	0
robot	0
and	0
its	0
respective	0
landmarks	0
are	0
not	0
known.	0
The	0
only	0
0	0
information	0
known	0
are	0
the	0
bearing	0
angles,	0
as	0
is	0
consistent	0
0	0
with	0
the	0
assumptions	0
in	0
our	0
paper.	0
With	0
the	0
proper	0
selection	0
0	0
of	0
the	0
cost	0
functional	0
for	0
the	0
optimization	0
process,	0
the	0
0	0
gradient	0
of	0
the	0
path	0
from	0
start	0
to	0
goal	0
(the	0
velocity	0
control	0
0	0
command	0
for	0
robot	0
i)	0
is	0
given	0
by	0
v	0
i	0
=	0
K	0
0	0
0	0
jL	0
i	0
(	0
i	0
0	0
j,des	0
i	0
0	0
j	0
),	0
0	0
where,	0
L	0
i	0
is	0
the	0
list	0
of	0
robots	0
that	0
are	0
neighbors	0
of	0
i,	0
0	0
and	0
which	0
can	0
be	0
used	0
as	0
landmarks,	0
i	0
0	0
j,des	0
is	0
the	0
desired	0
0	0
bearings	0
with	0
landmark	0
j,	0
and	0
K	0
is	0
a	0
gain.	0
Note	0
that	0
0	0
this	0
velocity	0
can	0
be	0
computed	0
in	0
the	0
instantaneous	0
local	0
0	0
coordinate	0
frame	0
of	0
the	0
robot	0
i.	0
This	0
controller	0
converges	0
0	0
to	0
the	0
goal	0
configuration	0
when	0
the	0
number	0
of	0
landmarks	0
is	0
0	0
greater	0
than	0
or	0
equal	0
to	0
two	0
and	0
not	0
co-linear	0
with	0
the	0
goal	0
0	0
location.	0
In	0
our	0
implementation,	0
the	0
controller	0
incorporates	0
0	0
adaptive	0
gain	0
scaling	0
in	0
order	0
to	0
obtain	0
faster	0
convergence.	0
0	0
We	0
also	0
use	0
adaptive	0
landmark	0
detection	0
depending	0
on	0
a	0
0	0
robots	0
neighbor	0
list	0
while	0
moving.	0
0	0
E.	0
Relative	0
H	0
2	0
Homology	0
0	0
We	0
periodically	0
compute	0
a	0
non-trivial	0
2-cycle	0
of	0
the	0
0	0
relative	0
complex	0
(R	0
rv	0
,	0
K)	0
so	0
that	0
we	0
can	0
identify	0
redun-	0
0	0
dant/extra	0
robots	0
that	0
can	0
be	0
removed	0
from	0
the	0
complex	0
0	0
without	0
sacrificing	0
sensor	0
coverage.	0
This	0
is	0
a	0
direct	0
applica-	0
0	0
tion	0
of	0
the	0
result	0
in	0
[11].	0
We	0
assume	0
some	0
familiarity	0
with	0
0	0
algebraic	0
topology	0
and	0
homology	0
theory	0
for	0
the	0
discussion	0
0	0
in	0
this	0
section	0
[17].	0
Given	0
the	0
simplicial	0
complex,	0
R	0
rv	0
,	0
and	0
0	0
the	0
fence	0
subcomplex,	0
K	0
=	0
F	0
O,	0
one	0
can	0
construct	0
a	0
0	0
relative	0
chain	0
complex,	0
C	0
(R	0
rv	0
,	0
K).	0
This,	0
in	0
essence,	0
is	0
0	0
the	0
complex	0
obtained	0
by	0
quotienting	0
out	0
the	0
subcomplex	0
0	0
K	0
(i.e.,	0
collapsing	0
K	0
to	0
a	0
single	0
point,	0
or	0
introducing	0
a	0
0	0
new	0
0-simplex,	0
Q,	0
and	0
connecting	0
2-simplices	0
{i,	0
j,	0
Q}	0
to	0
0	0
every	0
{i,	0
j}	0
K	0
as	0
illustrated	0
in	0
Figure	0
5).	0
Due	0
to	0
a	0
0	0
result	0
from	0
[11],	0
if	0
we	0
can	0
find	0
a	0
non-trivia	0
relative	0
cycle	0
in	0
0	0
C	0
2	0
(R	0
rv	0
,	0
K)	0
such	0
that	0
it	0
passes	0
through	0
all	0
the	0
0-simplices	0
0	0
in	0
the	0
fence,	0
K,	0
then	0
the	0
0-simplices	0
(the	0
robots)	0
making	0
up	0
0	0
that	0
cycle	0
is	0
sufficient	0
for	0
maintaining	0
the	0
sensor	0
coverage.	0
0	0
All	0
other	0
robots	0
can	0
be	0
reallocated.	0
0	0
8	0
0	0
12	0
0	0
10	0
0	0
11	0
0	0
6	0
0	0
7	0
0	0
3	0
0	0
2	0
0	0
1	0
0	0
9	0
0	0
5	0
0	0
4	0
0	0
13	0
0	0
(a)	0
A	0
Rips	0
complex,	0
Rr	0
v	0
,	0
with	0
the	0
0	0
frontier	0
subcomplex,	0
F	0
,	0
marked	0
in	0
0	0
cyan,	0
and	0
the	0
obstacle	0
subcomplex,	0
0	0
O,	0
marked	0
in	0
brown.	0
0	0
Q	0
0	0
8	0
0	0
12	0
0	0
10	0
0	0
11	0
0	0
6	0
0	0
7	0
0	0
3	0
0	0
2	0
0	0
1	0
0	0
9	0
0	0
5	0
0	0
4	0
0	0
13	0
0	0
(b)	0
Topology	0
of	0
the	0
space	0
where	0
the	0
0	0
entire	0
fence	0
complex,	0
F	0
O,	0
have	0
0	0
been	0
connected	0
through	0
2-simplices	0
0	0
to	0
an	0
external	0
0-simplex,	0
namely	0
Q.	0
0	0
Fig.	0
5.	0
An	0
example	0
where	0
a	0
redundant	0
robot	0
(#10)	0
can	0
be	0
identified	0
from	0
0	0
a	0
non-trivial	0
cycle	0
in	0
the	0
space	0
constructed	0
by	0
connecting	0
all	0
the	0
fence	0
0	0
simplices	0
to	0
a	0
single	0
external	0
0-simplex.	0
0	0
III.	0
ALGORITHM	0
DESIGN	0
0	0
The	0
outline	0
of	0
our	0
swarm	0
coverage	0
algorithm	0
is	0
presented	0
0	0
in	0
Algorithm	0
1.	0
We	0
begin	0
by	0
deploying	0
robot	0
1	0
into	0
the	0
0	0
unknown	0
environment	0
using	0
an	0
open-loop	0
control	0
so	0
that	0
it	0
0	0
maintains	0
visual	0
contact	0
with	0
the	0
source/base.	0
Then,	0
in	0
line	0
3,	0
0	0
3410	0
0	0
we	0
start	0
our	0
deployment	0
cycle	0
by	0
constructing	0
the	0
Rips	0
0	0
complex	0
in	0
a	0
distributed	0
manner	0
as	0
described	0
in	0
Section	0
II-B	0
0	0
(and	0
Algorithm	0
2).	0
Using	0
the	0
current	0
Rips	0
complex	0
R	0
rv	0
,	0
we	0
0	0
update	0
the	0
frontier,	0
F,	0
and	0
obstacle,	0
O,	0
subcomplexes	0
(line	0
4,	0
0	0
and	0
Algorithm	0
3)	0
along	0
with	0
computing	0
the	0
target	0
location	0
0	0
for	0
deployment	0
of	0
the	0
new	0
robot	0
in	0
the	0
local	0
coordinates	0
of	0
0	0
a	0
frontier	0
robot.	0
Note	0
that	0
at	0
the	0
end	0
of	0
the	0
first	0
deployment,	0
0	0
the	0
robot	0
1	0
belongs	0
to	0
F	0
(as	0
described	0
in	0
Section	0
III-A).	0
0	0
Although	0
our	0
implementation	0
uses	0
a	0
centralized	0
server	0
that	0
0	0
collects	0
local	0
information	0
from	0
the	0
individual	0
robots	0
through	0
0	0
an	0
emulated	0
wireless	0
communication	0
channel,	0
most	0
of	0
the	0
0	0
algorithmic	0
components	0
described	0
in	0
this	0
section	0
can	0
be	0
done	0
0	0
in	0
a	0
decentralized	0
fashion.	0
0	0
We	0
periodically	0
compute	0
relative	0
H	0
2	0
homology	0
to	0
identify	0
0	0
redundant	0
robots	0
for	0
redeployment	0
(line	0
5).	0
We	0
then	0
find	0
0	0
the	0
shortest	0
path	0
to	0
a	0
frontier	0
robot	0
(from	0
the	0
source	0
or	0
0	0
a	0
redundant	0
robot)	0
through	0
the	0
1-skeleton	0
of	0
the	0
complex	0
0	0
(line	0
6),	0
along	0
which	0
we	0
execute	0
the	0
push	0
action	0
(described	0
0	0
in	0
Section	0
III-B)	0
for	0
deployment	0
of	0
the	0
next	0
robot	0
(line	0
7).	0
In	0
0	0
presence	0
of	0
multiple	0
sources,	0
deployment	0
can	0
be	0
performed	0
0	0
in	0
parallel	0
along	0
multiple	0
paths	0
as	0
long	0
as	0
the	0
paths	0
do	0
not	0
0	0
intersect	0
(which	0
can	0
be	0
computed	0
using	0
an	0
optimal	0
routing	0
0	0
algorithm).	0
0	0
Algorithm	0
1	0
Swarm	0
Coverage	0
Overview	0
0	0
1:	0
Deploy	0
Robot	0
1;	0
n	0
1	0
0	0
2:	0
do	0
0	0
3:	0
0	0
Construct	0
Rips	0
cplx.	0
through	0
local	0
communication:	0
0	0
Rr	0
v	0
=	0
COMPUTERIPSCOMPLEX({Ni}i=1,2,	0
,n)	0
0	0
4:	0
0	0
Compute	0
fence	0
subcplx.	0
using	0
local	0
bearing	0
info.:	0
0	0
[F,	0
O]	0
=	0
FENCESUBCOMPLEX(Rr	0
v	0
,	0
{	0
a	0
0	0
bc	0
})	0
0	0
5:	0
0	0
(Periodically)	0
Identify	0
redundant	0
robots	0
using	0
H2	0
hom.	0
0	0
6:	0
0	0
Find	0
path	0
in	0
1-skeleton	0
for	0
Pushing	0
robots	0
0	0
7:	0
0	0
Push	0
robots	0
in	0
path	0
0	0
8:	0
0	0
Deploy	0
(n	0
+	0
1)	0
th	0
robot;	0
n	0
n	0
+	0
1	0
0	0
9:	0
while	0
F	0
=	0
0	0
Algorithm	0
2	0
Rr	0
v	0
=	0
COMPUTERIPSCOMPLEX({Ni}i=1,2,	0
,n)	0
0	0
Input:	0
Neighbor	0
information,	0
Ni,	0
i	0
=	0
1,	0
2,	0
,	0
n.	0
0	0
Output:	0
Rips	0
complex,	0
Rr	0
v	0
.	0
0	0
1:	0
Rr	0
v	0
0	0
2:	0
for	0
Robot	0
i	0
=	0
1,	0
...n	0
do	0
0	0
3:	0
0	0
Rr	0
v	0
Rr	0
v	0
{i}	0
0	0
4:	0
0	0
for	0
Robot	0
j	0
Ni	0
do	0
0	0
5:	0
0	0
Rr	0
v	0
Rr	0
v	0
{i,	0
j}	0
0	0
6:	0
0	0
for	0
Robot	0
k	0
Ni	0
do	0
0	0
7:	0
0	0
if	0
j	0
=	0
k	0
and	0
j	0
N	0
k	0
then	0
0	0
8:	0
0	0
Rr	0
v	0
Rr	0
v	0
{i,	0
j,	0
k}	0
0	0
9:	0
0	0
end	0
if	0
0	0
10:	0
0	0
end	0
for	0
0	0
11:	0
0	0
end	0
for	0
0	0
12:	0
end	0
for	0
0	0
A.	0
Identifying	0
Frontier	0
and	0
Obstacle	0
Subcomplexes	0
0	0
At	0
a	0
particular	0
robot	0
configuration,	0
X,	0
we	0
identify	0
the	0
1-	0
0	0
simplices	0
(and	0
the	0
corresponding	0
0-simplices	0
that	0
constitute)	0
0	0
in	0
the	0
Rips	0
complex,	0
R	0
rv	0
,	0
which	0
form	0
the	0
frontier	0
to	0
the	0
0	0
unexplored	0
regions,	0
as	0
well	0
as	0
the	0
ones	0
that	0
are	0
adjacent	0
0	0
to	0
the	0
obstacles.	0
They	0
respectively	0
constitute	0
the	0
frontier	0
0	0
subcomplex,	0
F,	0
and	0
the	0
obstacle	0
subcomplex,	0
O.	0
We	0
define	0
0	0
the	0
fence	0
subcomplex	0
as	0
K	0
=	0
F	0
O.	0
0	0
Algorithm	0
3	0
[F,	0
O]	0
=	0
FENCESUBCOMPLEX(Rr	0
v	0
,	0
{	0
a	0
0	0
bc	0
})	0
0	0
Input:	0
Rips	0
cplx.,	0
Rr	0
v	0
;	0
Relative	0
bearings,	0
a	0
0	0
bc	0
,	0
{a,	0
b,	0
c}	0
Rr	0
v	0
.	0
0	0
Output:	0
Frontier	0
subcomplex,	0
F;	0
Obstacle	0
subcomplex,	0
O	0
0	0
1:	0
F	0
,	0
O	0
0	0
2:	0
E	0
COMPUTEEXCEPTION(Rr	0
v	0
)	0
0	0
3:	0
for	0
{i,	0
j}	0
Rr	0
v	0
E	0
do	0
0	0
4:	0
0	0
UnCovij	0
{+1,	0
1}{sign(	0
i	0
0	0
jku	0
)|{i,	0
j,	0
ku}	0
Rr	0
v	0
}	0
0	0
5:	0
0	0
if	0
UnCovij	0
=	0
then	0
//	0
A	0
side	0
of	0
{i,	0
j}	0
is	0
uncovered.	0
0	0
6:	0
0	0
[	0
i	0
0	0
j,new	0
,	0
j	0
0	0
i,new	0
]DEPLOYMENTANGLE(i,	0
j,	0
UnCovij)	0
0	0
7:	0
0	0
if	0
{i,	0
j}	0
is	0
an	0
obstacle	0
simplex	0
then	0
0	0
8:	0
0	0
O	0
O	0
{{i},	0
{j},	0
{i,	0
j}}	0
0	0
9:	0
0	0
else	0
if	0
{i,	0
j}	0
is	0
a	0
fronter	0
simplex	0
then	0
0	0
10:	0
0	0
F	0
F	0
{{i},	0
{j},	0
{i,	0
j}}	0
0	0
11:	0
0	0
end	0
if	0
0	0
12:	0
0	0
end	0
if	0
0	0
13:	0
end	0
for	0
0	0
i	0
0	0
j	0
0	0
k	0
1	0
0	0
k	0
2	0
0	0
i	0
0	0
j	0
0	0
k	0
1	0
0	0
k	0
2	0
0	0
Fig.	0
7.	0
{i,	0
j,	0
k	0
1	0
}	0
and	0
{i,	0
j,	0
k	0
2	0
}	0
are	0
two	0
2-simplices	0
which	0
have	0
{i,	0
j}	0
in	0
0	0
their	0
boundaries.	0
{i,	0
j}	0
is	0
a	0
fence	0
1-simplex	0
if	0
both	0
k	0
1	0
and	0
k	0
2	0
lie	0
on	0
the	0
0	0
same	0
side	0
of	0
ij	0
(thick	0
purple	0
line	0
in	0
left	0
figure),	0
otherwise	0
not	0
(right	0
figure).	0
0	0
Algorithm	0
3	0
describes	0
our	0
method	0
of	0
identifying	0
the	0
0	0
frontier	0
subcomplex	0
and	0
obstacle	0
subcomplex.	0
We	0
begin	0
(line	0
0	0
2)	0
by	0
identifying	0
the	0
1-simplices	0
in	0
R	0
rv	0
that	0
are	0
part	0
of	0
0	0
an	0
exception	0
set,	0
E,	0
as	0
described	0
later	0
in	0
Section	0
III-A.1	0
0	0
(Figure	0
6(a)).	0
For	0
each	0
1-simplex	0
{i,	0
j}	0
in	0
R	0
rv	0
that	0
is	0
not	0
0	0
in	0
E,	0
we	0
then	0
compute	0
the	0
sign	0
of	0
i	0
0	0
jku	0
for	0
all	0
of	0
the	0
2-	0
0	0
simpilces	0
{i,	0
j,	0
k	0
u	0
}	0
R	0
rv	0
(i.e.,	0
the	0
ones	0
which	0
have	0
both	0
0	0
i	0
and	0
j	0
as	0
their	0
vertices).	0
If	0
all	0
the	0
2-simplices	0
adjacent	0
to	0
0	0
{i,	0
j}	0
lie	0
on	0
the	0
same	0
side	0
of	0
the	0
1-simplex	0
(Figure	0
7),	0
then	0
0	0
the	0
bearing	0
angle	0
to	0
all	0
the	0
robots	0
k	0
u	0
relative	0
to	0
j	0
(resp.	0
i)	0
0	0
have	0
the	0
same	0
sign,	0
and	0
thus	0
in	0
line	0
4,	0
UnCov	0
ij	0
is	0
not	0
empty.	0
0	0
Thus,	0
i,	0
j	0
belongs	0
to	0
the	0
fence	0
subcomplex,	0
and	0
we	0
compute	0
0	0
and	0
store	0
the	0
location	0
(in	0
the	0
local	0
coordinates	0
of	0
i	0
and	0
j)	0
0	0
for	0
potentially	0
deploying	0
a	0
new	0
robot	0
to	0
expand	0
the	0
frontier	0
0	0
using	0
a	0
pushing	0
action	0
(line	0
6).	0
The	0
exact	0
computation	0
of	0
0	0
the	0
bearings	0
to	0
the	0
potential	0
new	0
location,	0
i	0
0	0
j,new	0
,	0
j	0
0	0
i,new	0
,	0
is	0
0	0
described	0
in	0
subsection	0
III-A.2	0
and	0
Algorithm	0
4.	0
0	0
Finally,	0
in	0
lines	0
7-11,	0
we	0
classify	0
each	0
fence	0
simplex,	0
0	0
{i,	0
j},	0
as	0
frontier	0
or	0
obstacle	0
using	0
touch	0
sensor	0
readings	0
0	0
and	0
the	0
outputs	0
of	0
DEPLOYMENTANGLE	0
as	0
follows:	0
0	0
i.	0
If	0
i	0
and	0
j	0
are	0
in	0
contact	0
with	0
an	0
obstacle	0
(i.e.,	0
a	0
touch	0
0	0
sensor	0
is	0
activated,	0
and	0
there	0
are	0
no	0
robots	0
visible	0
in	0
the	0
0	0
direction	0
of	0
the	0
activated	0
touch	0
sensor)	0
in	0
the	0
expanding	0
0	0
direction,	0
then	0
the	0
1-simplex	0
{i,	0
j}	0
and	0
0-simplices	0
i,	0
j	0
0	0
are	0
placed	0
in	0
O	0
(Figure	0
6(b)).	0
0	0
ii.	0
Otherwise,	0
we	0
check	0
for	0
possibility	0
of	0
{i,	0
j}	0
being	0
0	0
an	0
obstacle	0
simplex	0
at	0
a	0
convex	0
corner	0
as	0
follows:	0
0	0
We	0
compute	0
the	0
closest	0
other	0
fence	0
1-simplex	0
at-	0
0	0
tached	0
to	0
i	0
and	0
j	0
(this	0
is	0
computed	0
as	0
a	0
part	0
of	0
the	0
0	0
DEPLOYMENTANGLE	0
procedure	0
say	0
it	0
is	0
{i,	0
k}).	0
If	0
0	0
the	0
magnitude	0
of	0
the	0
angle	0
between	0
ik	0
and	0
ij	0
is	0
less	0
0	0
than	0
0	0
3	0
2	0
(figure	0
6(c),	0
where	0
is	0
the	0
error	0
in	0
0	0
measurement	0
of	0
bearings	0
to	0
neighbors),	0
then	0
the	0
two	0
0	0
robots,	0
j	0
and	0
k,	0
do	0
not	0
see	0
each	0
other	0
due	0
to	0
occlusion	0
0	0
by	0
an	0
obstacle,	0
but	0
every	0
free	0
point	0
(points	0
outside	0
0	0
3411	0
0	0
i	0
0	0
j	0
0	0
k	0
0	0
k	0
1	0
0	0
k	0
2	0
0	0
(a)	0
Exception	0
case	0
where	0
a	0
1-simplex,	0
0	0
{i,	0
j},	0
has	0
all	0
adjacent	0
1-simplices	0
0	0
lying	0
on	0
the	0
same	0
side,	0
but	0
is	0
not	0
a	0
0	0
fence	0
simplex.	0
This	0
can	0
be	0
detected	0
0	0
from	0
the	0
perspective	0
of	0
robot	0
k.	0
0	0
i	0
0	0
j	0
0	0
jo	0
0	0
io	0
0	0
i	0
0	0
j	0
0	0
(b)	0
Detecting	0
that	0
a	0
1-simplex,	0
{i,	0
j},	0
0	0
is	0
in	0
O	0
Rrv	0
(thick	0
brown	0
line).	0
0	0
i	0
0	0
j	0
0	0
k	0
0	0
(c)	0
Convex	0
corner	0
case	0
where	0
a	0
0	0
pair	0
of	0
1-simplices,	0
{i,	0
j1}	0
and	0
0	0
{i,	0
j2},	0
are	0
recognized	0
as	0
obstacle	0
0	0
1-simplices	0
(thick	0
brown	0
lines).	0
0	0
j2	0
0	0
i	0
0	0
j1	0
0	0
(d)	0
If	0
the	0
robot	0
i	0
is	0
to	0
be	0
pushed	0
0	0
along	0
a	0
path	0
in	0
the	0
graph	0
to	0
expand	0
0	0
frontier	0
{i,	0
j1},	0
it	0
performs	0
a	0
test	0
0	0
drive	0
to	0
ensure	0
an	0
obstacle	0
is	0
not	0
0	0
right	0
in	0
front	0
of	0
it.	0
0	0
Fig.	0
6.	0
Identifying	0
simplices	0
for	0
fence	0
subcomplex	0
K	0
=	0
F	0
O.	0
0	0
obstacles)	0
in	0
their	0
convex	0
hull	0
is	0
in	0
the	0
visibility	0
disk	0
of	0
0	0
at	0
least	0
one	0
robot	0
(aside	0
from	0
possibly	0
small	0
non-convex	0
0	0
sub-features	0
present	0
in	0
that	0
convex	0
corner,	0
which	0
we	0
0	0
ignore).	0
Thus,	0
these	0
1-simplices	0
are	0
marked	0
as	0
obstacle	0
0	0
1-simplices	0
to	0
be	0
pushed	0
into	0
O.	0
0	0
iii.	0
Otherwise,	0
at	0
least	0
one	0
of	0
the	0
robots	0
can	0
be	0
ex-	0
0	0
panded/moved	0
to	0
the	0
unexplored	0
region,	0
and	0
thus	0
{i,	0
j}	0
0	0
is	0
placed	0
in	0
F	0
along	0
with	0
the	0
corresponding	0
robots	0
0	0
(Figure	0
7,	0
left).	0
0	0
iv.	0
Additionally,	0
if	0
{i,	0
j}	0
F	0
due	0
to	0
iii.,	0
and	0
i	0
belongs	0
0	0
to	0
the	0
path	0
for	0
planned	0
deployment,	0
we	0
perform	0
a	0
test	0
0	0
drive	0
in	0
the	0
planned	0
deployment	0
direction	0
for	0
a	0
small	0
0	0
distance	0
to	0
ensure	0
sufficient	0
space	0
availability	0
for	0
new	0
0	0
deployment	0
near	0
obstacles	0
(Figure	0
6(d)).	0
0	0
The	0
complete	0
illustration	0
of	0
the	0
process	0
of	0
identifying	0
1-	0
0	0
simplices	0
as	0
part	0
of	0
F	0
or	0
O	0
is	0
given	0
in	0
Figures	0
7	0
and	0
9(a).	0
0	0
We	0
next	0
describe	0
the	0
COMPUTEEXCEPTION	0
and	0
DEPLOY-	0
0	0
MENTANGLE	0
procedures.	0
0	0
1)	0
The	0
Exception	0
Case:	0
The	0
aforesaid	0
approach	0
in	0
de-	0
0	0
tecting	0
fence	0
1-simplices	0
using	0
UnCovij	0
may	0
give	0
false	0
0	0
positives	0
in	0
some	0
cases	0
when	0
a	0
1-simplex,	0
{i,	0
j},	0
is	0
com-	0
0	0
pletely	0
covered	0
by	0
2	0
simplices,	0
of	0
which	0
{i,	0
j}	0
do	0
not	0
form	0
0	0
a	0
boundary,	0
as	0
shown	0
in	0
Figure	0
6(a).	0
Nevertheless,	0
this	0
0	0
special	0
case	0
can	0
be	0
easily	0
detected	0
from	0
the	0
perspective	0
of	0
0	0
a	0
common	0
neighbor,	0
k,	0
of	0
i,	0
j.	0
If	0
it	0
is	0
detected	0
that	0
k	0
ij	0
=	0
0	0
k	0
ik1	0
+	0
k	0
k1k2	0
+	0
+	0
k	0
krj	0
(for	0
some	0
k1,	0
,	0
kr	0
Nk),	0
such	0
0	0
that	0
all	0
the	0
summands	0
have	0
the	0
same	0
sign	0
as	0
the	0
summation,	0
0	0
then	0
clearly	0
{i,	0
j}	0
lies	0
inside	0
2-simplices	0
of	0
which	0
{i,	0
j}	0
do	0
0	0
not	0
form	0
a	0
boundary	0
but	0
k	0
is	0
a	0
vertex.	0
Then	0
{i,	0
j}	0
is	0
marked	0
0	0
as	0
an	0
exception	0
1-simplex.	0
0	0
2)	0
Identifying	0
Locations	0
for	0
Robot	0
Placement	0
(Hexagonal	0
0	0
Packing):	0
Given	0
a	0
1-simplex	0
{i,	0
j}	0
F	0
and	0
the	0
uncovered	0
0	0
direction	0
{+1,	0
1},	0
we	0
need	0
to	0
find,	0
in	0
the	0
local	0
0	0
coordinates	0
of	0
i	0
and	0
j,	0
the	0
location	0
for	0
the	0
new	0
robot	0
position.	0
0	0
Figure	0
8(a)	0
illustrates	0
the	0
uncovered	0
side	0
of	0
1-simplex	0
{i,	0
j}	0
0	0
in	0
is	0
local	0
coordinate.	0
Our	0
strategy	0
for	0
choosing	0
the	0
position	0
0	0
to	0
deploy	0
next	0
robot	0
is	0
to	0
try	0
and	0
achieve	0
a	0
hexagonal	0
0	0
packing	0
[19]	0
(which	0
is	0
the	0
most	0
optimal	0
packing	0
on	0
an	0
0	0
obstacle-free	0
pane)	0
of	0
robots	0
as	0
much	0
as	0
possible,	0
only	0
0	0
to	0
be	0
interrupted	0
by	0
the	0
presence	0
of	0
obstacles	0
or	0
controls	0
0	0
error.	0
This	0
essentially	0
boils	0
down	0
to	0
sending	0
robots	0
at	0
an	0
0	0
angle	0
of	0
60(=	0
0	0
3	0
)	0
with	0
respect	0
to	0
ij	0
into	0
the	0
free	0
region.	0
0	0
Algorithm	0
4	0
describes	0
our	0
DEPLOYMENTANGLE	0
function	0
0	0
which	0
first	0
determines	0
(lines	0
3-6)	0
the	0
closest	0
other	0
fence	0
0	0
1-simplices	0
attached	0
to	0
i	0
and	0
j	0
(e.g.,	0
{i,	0
k}	0
in	0
Figure	0
8(b)).	0
0	0
If	0
there	0
is	0
no	0
other	0
fence	0
1-simplex	0
attached	0
to	0
i,	0
we	0
set	0
Algorithm	0
4	0
[i	0
j,new	0
,	0
j	0
i,new	0
]	0
=	0
DEPLOYMENTANGLE	0
(i,	0
j,	0
UnCovij)	0
0	0
Input:	0
Robots	0
i,	0
j;	0
the	0
side	0
of	0
ij	0
that	0
is	0
open/uncovered.	0
0	0
Output:	0
New	0
location	0
for	0
deployment	0
in	0
local	0
coordinates	0
of	0
i,	0
j,	0
0	0
or,	0
{i,	0
j}	0
is	0
marked	0
an	0
obstacle	0
simplex.	0
0	0
1:	0
i	0
j,new	0
,	0
j	0
i,new	0
0	0
2:	0
for	0
in	0
UnCovij	0
do	0
0	0
3:	0
0	0
Si	0
{l	0
|	0
{i,	0
l}	0
Rrv	0
and	0
sign(i	0
j,l)	0
=	0
}	0
0	0
4:	0
0	0
ki	0
arg	0
minkSi	0
|i	0
j,k	0
|	0
0	0
5:	0
0	0
Sj	0
{l	0
|	0
{j,	0
l}	0
Rrv	0
and	0
sign(j	0
i,l)	0
=	0
}	0
0	0
6:	0
0	0
kj	0
arg	0
minkSj	0
|j	0
i,k	0
|	0
0	0
7:	0
0	0
if	0
|i	0
j,ki	0
|	0
<	0
0	0
3	0
(or	0
|j	0
i,kj	0
|	0
<	0
0	0
3	0
)	0
then	0
0	0
8:	0
0	0
Mark	0
{i,	0
ki}	0
(or	0
{j,	0
kj})	0
as	0
an	0
obstacle	0
simplex.	0
0	0
9:	0
0	0
else	0
0	0
10:	0
0	0
i	0
j,new	0
min{	0
0	0
3	0
,	0
|	0
i	0
j,ki	0
0	0
2	0
|}	0
0	0
11:	0
0	0
j	0
i,new	0
min{	0
0	0
3	0
,	0
|	0
j	0
i,kj	0
0	0
2	0
|}	0
0	0
12:	0
0	0
end	0
if	0
0	0
13:	0
end	0
for	0
0	0
i	0
new	0
=	0
i	0
j	0
+	0
i	0
j	0
0	0
3	0
the	0
60	0
angle	0
for	0
deployment	0
in	0
0	0
a	0
hexagonal	0
packing.	0
Otherwise	0
we	0
set	0
the	0
angle	0
to	0
the	0
0	0
minimum	0
between	0
the	0
one	0
for	0
hexagonal	0
packaging	0
(	0
0	0
3	0
)	0
and	0
0	0
the	0
the	0
one	0
that	0
bisects	0
i	0
jki	0
.	0
Likewise	0
for	0
j	0
new.	0
0	0
i	0
0	0
j	0
0	0
u	0
0	0
ju	0
i	0
0	0
Valid	0
bearing	0
0	0
for	0
new	0
robot	0
0	0
new	0
0	0
(a)	0
The	0
free	0
side	0
of	0
{i,	0
j}	0
0	0
where	0
sign(i	0
j,new	0
)	0
=	0
.	0
0	0
ij	0
0	0
k	0
0	0
jk	0
i	0
0	0
j,new	0
i	0
0	0
(b)	0
The	0
bearing	0
to	0
the	0
new	0
location,	0
0	0
i	0
j,new=min{	0
0	0
3	0
,	0
i	0
jk	0
0	0
2	0
},	0
in	0
is	0
local	0
coord.	0
0	0
Fig.	0
8.	0
Determining	0
bearing	0
to	0
the	0
new	0
location.	0
0	0
If	0
i	0
is	0
not	0
attached	0
to	0
a	0
frontier	0
1-simplex	0
(e.g.,	0
i	0
is	0
0	0
a	0
frontier	0
robot	0
in	0
a	0
narrow	0
passage	0
with	0
a	0
single	0
file	0
of	0
0	0
robots),	0
then	0
we	0
simply	0
choose	0
the	0
direction	0
away	0
from	0
the	0
0	0
neighbors	0
of	0
i	0
as	0
the	0
bearing	0
to	0
the	0
new	0
location	0
(in	0
the	0
local	0
0	0
coordinates	0
of	0
i)	0
for	0
deployment	0
of	0
the	0
new	0
robot.	0
0	0
B.	0
Identifying	0
Path	0
in	0
1-skeleton	0
for	0
Pushing	0
Robots	0
0	0
The	0
strategy	0
in	0
our	0
algorithm	0
for	0
robot	0
deployment	0
in	0
0	0
every	0
control	0
cycle	0
is	0
to	0
keep	0
the	0
structure	0
of	0
the	0
existing	0
0	0
simplicial	0
complex	0
(and	0
hence	0
the	0
positions	0
of	0
the	0
existing	0
0	0
robots	0
in	0
W	0
)	0
unchanged.	0
New	0
robots	0
are	0
deployed	0
through	0
0	0
the	0
complex	0
simply	0
by	0
pushing	0
through	0
paths	0
(i.e.,	0
making	0
0	0
each	0
robot	0
on	0
a	0
path	0
move	0
forward	0
to	0
take	0
the	0
place	0
of	0
the	0
0	0
one	0
in	0
front	0
of	0
it)	0
in	0
the	0
1-skeleton	0
(graph)	0
of	0
the	0
complex	0
0	0
(Figure	0
9).	0
For	0
computing	0
this	0
path,	0
a	0
centralized	0
knowledge	0
0	0
3412	0
0	0
of	0
the	0
entire	0
1-skeleton	0
is	0
used	0
(constructed	0
by	0
the	0
robots	0
0	0
communicating	0
each	0
of	0
their	0
local	0
information	0
the	0
IDs	0
of	0
0	0
the	0
neighbors	0
that	0
each	0
see	0
to	0
a	0
central	0
server	0
via	0
wireless	0
0	0
communication),	0
although	0
the	0
computation	0
of	0
the	0
path	0
can	0
0	0
indeed	0
be	0
performed	0
in	0
a	0
decentralized	0
manner	0
through	0
peer-	0
0	0
to-peer	0
communication	0
only	0
(see	0
[20]	0
for	0
a	0
decentralized	0
0	0
implementation	0
of	0
the	0
Dijkstras	0
algorithm).	0
0	0
We	0
consider	0
the	0
graph	0
made	0
out	0
of	0
the	0
1	0
and	0
0	0
simplices	0
0	0
in	0
R	0
rv	0
.	0
The	0
frontier	0
subcomplex,	0
F,	0
computed	0
in	0
previous	0
0	0
section	0
(the	0
0-simplices	0
in	0
it)	0
provides	0
the	0
list	0
of	0
robots	0
0	0
which	0
we	0
need	0
to	0
potentially	0
move	0
to	0
expand	0
the	0
frontier.	0
We	0
0	0
assign	0
a	0
cost	0
of	0
1	0
to	0
all	0
the	0
1-simplices	0
in	0
the	0
graph,	0
except	0
0	0
the	0
1-simplies	0
in	0
O,	0
to	0
which	0
we	0
assign	0
cost	0
of	0
w	0
O	0
>	0
1	0
0	0
in	0
order	0
to	0
avoid	0
paths	0
that	0
pass	0
through	0
robots	0
adjacent	0
0	0
to	0
obstacles,	0
where	0
navigation	0
is	0
more	0
challenging.	0
We	0
use	0
0	0
Dijkstras	0
search	0
algorithm	0
to	0
find	0
the	0
shortest	0
path	0
from	0
the	0
0	0
source,	0
which	0
is	0
the	0
robot	0
next	0
to	0
the	0
base	0
station	0
(in	0
case	0
0	0
of	0
multiple	0
source,	0
we	0
can	0
initiate	0
the	0
open	0
list	0
in	0
Dijkstras	0
0	0
algorithm	0
with	0
the	0
multiple	0
sources	0
as	0
illustrated	0
in	0
[5]),	0
to	0
0	0
the	0
closest	0
vertex	0
(0-simplex)	0
in	0
F.	0
0	0
Robots	0
are	0
then	0
pushed	0
along	0
this	0
path	0
where	0
each	0
robot	0
0	0
on	0
the	0
path	0
simply	0
gets	0
replaced	0
by	0
the	0
one	0
behind	0
it	0
on	0
0	0
the	0
path,	0
while	0
the	0
robot	0
that	0
is	0
on	0
the	0
frontier	0
computes	0
0	0
(as	0
described	0
next)	0
and	0
moves	0
to	0
a	0
new	0
location	0
in	0
the	0
0	0
free/unexplored	0
region.	0
Since	0
robots	0
on	0
the	0
path	0
get	0
replaced	0
0	0
by	0
the	0
robots	0
behind	0
them,	0
this	0
requires	0
that	0
we	0
not	0
only	0
0	0
update	0
the	0
IDs	0
in	0
R	0
rv	0
,	0
but	0
also	0
the	0
robot	0
IDs	0
in	0
F	0
and	0
O.	0
0	0
8	0
0	0
12	0
0	0
10	0
0	0
11	0
0	0
6	0
0	0
7	0
0	0
3	0
0	0
2	0
0	0
1	0
0	0
9	0
0	0
source	0
0	0
5	0
0	0
4	0
0	0
(a)	0
Shortest	0
path	0
12	0
10	0
6	0
2	0
0	0
identified	0
from	0
the	0
source	0
to	0
a	0
vertex	0
0	0
in	0
F	0
.	0
0	0
8	0
0	0
12	0
0	0
10	0
0	0
11	0
0	0
6	0
0	0
7	0
0	0
3	0
0	0
2	0
0	0
1	0
0	0
9	0
0	0
source	0
0	0
5	0
0	0
4	0
0	0
13	0
0	0
(b)	0
Robots	0
are	0
pushed	0
along	0
the	0
0	0
path.	0
Notice	0
how	0
the	0
new	0
robot	0
13	0
0	0
appears	0
near	0
the	0
source.	0
0	0
Fig.	0
9.	0
The	0
complex	0
Rr	0
v	0
,	0
and	0
the	0
subcomplexes	0
F	0
(cyan)	0
and	0
O	0
(brown).	0
0	0
Path	0
through	0
the	0
1-skeleton	0
illustrate	0
pushing	0
0	0
C.	0
Control	0
of	0
Robots	0
0	0
We	0
use	0
the	0
visual	0
homing	0
controller	0
described	0
in	0
Sec-	0
0	0
tion	0
II-D	0
(Figure	0
10(a)).	0
For	0
a	0
frontier	0
robot,	0
i,	0
the	0
desired	0
0	0
bearings	0
i	0
0	0
j,des	0
can	0
be	0
computed	0
easily	0
for	0
the	0
planned	0
0	0
direction	0
for	0
deployment	0
of	0
the	0
new	0
robot	0
(	0
j	0
0	0
new	0
in	0
the	0
current	0
0	0
coordinate	0
frame	0
if	0
robot	0
i),	0
and	0
assuming	0
that	0
the	0
robots	0
are	0
0	0
separated	0
by	0
a	0
distance	0
of	0
r	0
v	0
.	0
For	0
every	0
other	0
robot,	0
i	0
,	0
0	0
on	0
the	0
path	0
through	0
which	0
robots	0
are	0
being	0
pushed,	0
i	0
0	0
j,des	0
0	0
are	0
the	0
current	0
bearing	0
values	0
for	0
the	0
robot	0
ahead	0
of	0
i	0
in	0
the	0
0	0
path	0
(with	0
correct	0
ID	0
re-orderings	0
performed).	0
0	0
When	0
robots	0
are	0
being	0
pushed	0
along	0
a	0
path,	0
multiple	0
0	0
robots	0
move	0
simultaneously,	0
and	0
for	0
a	0
robot	0
moving	0
on	0
the	0
0	0
path,	0
some	0
of	0
its	0
landmarks	0
(i.e.,	0
neighbors)	0
are	0
themselves	0
0	0
moving.	0
The	0
bearing-based	0
controller	0
that	0
we	0
use,	0
is	0
in	0
fact	0
0	0
capable	0
of	0
dealing	0
with	0
moving	0
landmarks,	0
and	0
give	0
similar	0
0	0
convergence	0
properties.	0
A	0
few	0
static	0
landmarks	0
(at	0
least	0
two	0
0	0
in	0
total)	0
referenced	0
by	0
some	0
of	0
the	0
moving	0
robots	0
on	0
the	0
0	0
path	0
are	0
sufficient	0
in	0
attaining	0
convergence.	0
In	0
addition,	0
the	0
0	0
desired	0
bearing	0
is	0
set	0
for	0
each	0
robot	0
for	0
all	0
of	0
their	0
sur-	0
0	0
rounding	0
neighbors.	0
This	0
allows	0
robots	0
to	0
adaptively	0
correct	0
0	0
their	0
trajectory	0
while	0
simultaneously	0
gaining	0
and	0
loosing	0
0	0
landmarks	0
along	0
their	0
trajectory.	0
0	0
No	0
robots	0
reference	0
the	0
robot	0
that	0
is	0
moving	0
to	0
a	0
new	0
0	0
(unexplored)	0
location	0
for	0
expanding	0
the	0
frontier.	0
This	0
is	0
0	0
because	0
there	0
are	0
uncertainties	0
about	0
the	0
unexplored	0
region	0
0	0
(e.g.,	0
about	0
presence	0
of	0
obstacles),	0
and	0
errors	0
due	0
to	0
that	0
0	0
should	0
not	0
propagate	0
upstream.	0
Furthermore,	0
if	0
a	0
robot	0
does	0
0	0
not	0
have	0
more	0
than	0
one	0
another	0
robot	0
to	0
reference	0
to	0
as	0
0	0
landmark,	0
it	0
employs	0
an	0
open-loop	0
control	0
to	0
reach	0
the	0
0	0
desired	0
location	0
using	0
odometry	0
estimate,	0
and	0
drives	0
back	0
0	0
in	0
case	0
it	0
loses	0
the	0
single	0
visual	0
link	0
that	0
it	0
had.	0
This	0
is	0
0	0
unavoidable	0
when,	0
for	0
example,	0
the	0
robots	0
move	0
in	0
a	0
narrow	0
0	0
passage	0
in	0
a	0
single	0
file.	0
0	0
1)	0
Action	0
on	0
Touching	0
an	0
Obstacle:	0
Upon	0
touching	0
an	0
0	0
obstacle	0
at	0
a	0
bearing	0
of	0
i	0
0	0
o	0
(	0
being	0
the	0
resolution	0
in	0
the	0
0	0
measurement	0
of	0
bearing	0
to	0
touch),	0
the	0
robot	0
will	0
not	0
be	0
able	0
0	0
to	0
progress	0
in	0
the	0
direction	0
between	0
(	0
i	0
0	0
o	0
0	0
2	0
+,	0
i	0
0	0
jo	0
+	0
0	0
2	0
)	0
0	0
(Figure	0
10(b)).	0
Hence,	0
if	0
the	0
command	0
velocity,	0
v	0
i	0
,	0
computed	0
0	0
using	0
the	0
bearing-only	0
controller	0
pushes	0
the	0
robot	0
inside	0
an	0
0	0
obstacle,	0
we	0
take	0
the	0
best	0
projection	0
of	0
that	0
velocity	0
into	0
the	0
0	0
set	0
of	0
allowed	0
velocities	0
(u	0
i	0
in	0
the	0
figure,	0
falling	0
inside	0
the	0
0	0
brown	0
sector)	0
such	0
that	0
using	0
u	0
i	0
as	0
the	0
velocity	0
command	0
0	0
the	0
robot	0
moves	0
out	0
toward	0
the	0
obstacle-free	0
area	0
freeing	0
0	0
itself	0
from	0
the	0
obstacle.	0
Overall,	0
this	0
results	0
in	0
a	0
behavior	0
0	0
akin	0
to	0
sliding	0
along	0
the	0
obstacle	0
using	0
the	0
component	0
of	0
0	0
the	0
velocity	0
parallel	0
to	0
the	0
obstacle.	0
0	0
(a)	0
The	0
bearing-based	0
controller	0
0	0
uses	0
neighbors	0
as	0
landmarks	0
and	0
0	0
use	0
the	0
bearing	0
angles	0
to	0
them	0
to	0
0	0
navigate	0
to	0
the	0
desired	0
location	0
0	0
knowing	0
the	0
desired	0
bearing	0
an-	0
0	0
gles.	0
0	0
v	0
i	0
0	0
0	0
u	0
i	0
0	0
(b)	0
Upon	0
touching	0
an	0
obstacle,	0
0	0
the	0
robot	0
use	0
the	0
component	0
of	0
0	0
the	0
computed	0
velocity	0
that	0
is	0
the	0
0	0
projection	0
in	0
the	0
valid/free	0
sector	0
0	0
(brown).	0
0	0
Fig.	0
10.	0
Components	0
of	0
the	0
controller.	0
0	0
2)	0
Scale	0
Correction:	0
Since	0
our	0
controller	0
is	0
purely	0
0	0
bearing-based,	0
and	0
although	0
we	0
attempt	0
to	0
create	0
a	0
hexagonal	0
0	0
packing,	0
small	0
accumulation	0
of	0
the	0
errors	0
can	0
decrease	0
the	0
0	0
average	0
separation	0
between	0
the	0
robots	0
as	0
we	0
move	0
further	0
0	0
away	0
from	0
the	0
source.	0
To	0
correct	0
this,	0
we	0
perform	0
a	0
scale	0
0	0
correction	0
periodically,	0
where	0
we	0
make	0
a	0
frontier	0
robot,	0
0	0
i,	0
move	0
forward	0
keeping	0
the	0
reference	0
robots	0
behind	0
it	0
0	0
(opposite	0
to	0
a	0
mean	0
bearing	0
to	0
those	0
robots),	0
until	0
it	0
breaks	0
0	0
visual	0
link	0
with	0
at	0
least	0
one	0
of	0
those	0
neighboring	0
robots.	0
0	0
Then	0
we	0
make	0
the	0
robot	0
i	0
drive	0
back	0
until	0
it	0
reestablishes	0
0	0
the	0
visual	0
link	0
with	0
all	0
its	0
neighbors.	0
This	0
ensures	0
that	0
the	0
0	0
average	0
separation	0
between	0
the	0
robots	0
stay	0
in	0
O(r	0
v	0
).	0
0	0
D.	0
Identification	0
and	0
Reallocation	0
of	0
Redundant	0
Robots	0
0	0
Using	0
the	0
method	0
described	0
in	0
[11]	0
and	0
briefly	0
discussed	0
0	0
in	0
Section	0
II-E,	0
we	0
can	0
identify	0
redundant	0
robots	0
in	0
the	0
0	0
complex	0
by	0
computing	0
a	0
generator	0
(non-trivial	0
relative	0
cycle)	0
0	0
of	0
the	0
relative	0
homology	0
H	0
2	0
(R	0
rv	0
,	0
K),	0
where	0
K	0
=	0
F	0
O	0
0	0
3413	0
0	0
is	0
the	0
fence	0
subcomplex.	0
We	0
use	0
the	0
JavaPlex	0
[21]	0
library	0
0	0
for	0
the	0
computation	0
of	0
the	0
non-trivial	0
relative	0
cycle	0
using	0
0	0
persistence	0
algorithm.	0
The	0
required	0
filtration	0
over	0
R	0
rv	0
is	0
0	0
achieved	0
by	0
inserting	0
the	0
0,	0
1	0
and	0
2	0
dimensional	0
simplices	0
0	0
in	0
sequence.	0
We	0
add	0
a	0
disjoint	0
0-simplex,	0
Q,	0
as	0
illustrated	0
0	0
in	0
Figure	0
5(b),	0
and	0
construct	0
the	0
1-simplices	0
{i,	0
Q}	0
and	0
the	0
0	0
2-simplices	0
{i,	0
j,	0
Q},	0
for	0
every	0
0-simplex,	0
i,	0
in	0
K,	0
and	0
every	0
0	0
1-simplex,	0
{i,	0
j},	0
in	0
K.	0
Call	0
this	0
new	0
complex	0
(R	0
rv	0
,	0
K).	0
0	0
Computation	0
of	0
persistent	0
homology	0
up	0
to	0
dimension	0
2	0
for	0
0	0
this	0
complex	0
with	0
Z	0
2	0
coefficients	0
using	0
JavaPlex	0
gives	0
us	0
0	0
a	0
set	0
of	0
non-trivial	0
generating	0
2-cycles	0
in	0
(R	0
rv	0
,	0
K)	0
which	0
0	0
generate	0
H	0
2	0
(R	0
rv	0
,	0
K).	0
Any	0
non-zero	0
linear	0
combination	0
(in	0
0	0
Z	0
2	0
coefficients)	0
of	0
these	0
cycles	0
will	0
also	0
be	0
a	0
valid	0
non-	0
0	0
trivial	0
2-cycle	0
which	0
can	0
be	0
used	0
to	0
identify	0
the	0
robots	0
that	0
0	0
are	0
sufficient	0
for	0
maintaining	0
coverage.	0
Thus	0
we	0
perform	0
0	0
a	0
greedy	0
search	0
for	0
the	0
best	0
linear	0
combination	0
(a	0
linear	0
0	0
combination	0
of	0
cycles	0
such	0
that	0
it	0
contains	0
the	0
least	0
number	0
0	0
of	0
0-simplices)	0
that	0
also	0
contain	0
all	0
the	0
fence	0
0-simplices.	0
0	0
Thus,	0
finally	0
we	0
have	0
a	0
set	0
of	0
0-simplices	0
which	0
constitute	0
0	0
robots	0
that	0
are	0
sufficient	0
to	0
maintain	0
the	0
sensor	0
coverage	0
that	0
0	0
is	0
currently	0
being	0
maintained.	0
All	0
other	0
robots	0
are	0
redundant	0
0	0
and	0
can	0
be	0
removed/reallocated.	0
Once	0
we	0
have	0
identified	0
the	0
0	0
redundant	0
robots,	0
in	0
the	0
next	0
deployment	0
cycle	0
we	0
use	0
them,	0
0	0
instead	0
of	0
deploying	0
new	0
ones	0
from	0
the	0
source.	0
0	0
IV.	0
GUARANTEES	0
0	0
Since	0
throughout	0
the	0
deployment	0
and	0
covering	0
process	0
we	0
0	0
keep	0
the	0
graph	0
(1-skeleton	0
of	0
R	0
rv	0
)	0
of	0
the	0
already-covered	0
0	0
region	0
fixed	0
(we	0
only	0
push	0
robots	0
along	0
paths	0
in	0
the	0
0	0
graph	0
to	0
the	0
frontiers),	0
we	0
eliminate	0
the	0
possibility	0
that	0
0	0
the	0
algorithm	0
gets	0
stuck	0
in	0
an	0
infinite	0
cycle	0
in	0
which	0
the	0
0	0
graph	0
keeps	0
cycling/switching	0
between	0
two	0
configurations.	0
0	0
Furthermore,	0
by	0
choosing	0
to	0
keep	0
the	0
graph	0
structure	0
fixed	0
0	0
across	0
deployment	0
cycles,	0
we	0
eliminate	0
the	0
possibility	0
that	0
0	0
our	0
control	0
algorithm	0
results	0
in	0
recession	0
of	0
a	0
frontier	0
or	0
0	0
opens	0
up	0
a	0
new	0
hole	0
in	0
the	0
already-covered	0
region	0
of	0
the	0
0	0
environment.	0
If	0
due	0
to	0
accumulation	0
of	0
errors	0
we	0
do	0
open	0
0	0
up	0
a	0
hole,	0
and	0
hence	0
a	0
new	0
set	0
of	0
frontier	0
1-simplices	0
appear,	0
0	0
we	0
send	0
robots	0
to	0
those	0
frontier	0
1-simplices	0
to	0
fill	0
the	0
hole.	0
0	0
Algorithm	0
Termination:	0
The	0
algorithm,	0
as	0
described,	0
will	0
0	0
keep	0
deploying	0
robots	0
to	0
frontier	0
1-simplices	0
as	0
long	0
as	0
they	0
0	0
exist.	0
In	0
absence	0
of	0
obstacles	0
nearby,	0
a	0
robot	0
will	0
be	0
deployed	0
0	0
for	0
every	0
frontier	0
1-simplex	0
at	0
an	0
angle	0
of	0
60	0
with	0
the	0
0	0
simplex	0
into	0
the	0
uncovered	0
region.	0
This	0
will	0
always	0
make	0
0	0
the	0
frontier	0
progress	0
(as	0
illustrated	0
in	0
Figure	0
9).	0
Although	0
0	0
this	0
may	0
result	0
in	0
deployment	0
of	0
redundant	0
robots	0
(which	0
are	0
0	0
later	0
identified	0
and	0
removed	0
using	0
the	0
relative	0
H	0
2	0
homology	0
0	0
generator	0
computation),	0
the	0
progress	0
in	0
the	0
expansion	0
of	0
the	0
0	0
frontier	0
is	0
always	0
finite	0
in	0
obstacle-free	0
regions.	0
Neverthe-	0
0	0
less,	0
when	0
the	0
expanding	0
location	0
lies	0
inside	0
an	0
obstacle	0
we	0
0	0
need	0
to	0
consider,	0
and	0
thus	0
avoid,	0
the	0
possibility	0
that	0
robots	0
0	0
are	0
deployed	0
indefinitely	0
to	0
a	0
region	0
close	0
to	0
an	0
obstacle	0
0	0
because	0
the	0
unexplored	0
region	0
changing	0
only	0
infinitesimally	0
0	0
at	0
each	0
deployment.	0
This	0
is	0
however	0
prevented	0
by	0
the	0
design	0
0	0
of	0
our	0
algorithm,	0
as	0
described	0
in	0
Section	0
III-A	0
item	0
iv.,	0
0	0
where	0
we	0
prevent	0
the	0
deployment	0
of	0
unnecessary	0
robots	0
near	0
0	0
obstacles	0
that	0
make	0
little	0
to	0
no	0
progress	0
in	0
expanding	0
the	0
0	0
frontier.	0
Thus,	0
in	0
a	0
finite	0
environment	0
the	0
algorithm	0
will	0
0	0
terminate	0
with	0
no	0
more	0
frontiers	0
left	0
for	0
exploration.	0
0	0
Algorithmic	0
Completeness:	0
As	0
described,	0
when	0
F	0
is	0
not	0
0	0
empty,	0
more	0
robots	0
will	0
be	0
deployed	0
to	0
close	0
the	0
frontier.	0
0	0
When	0
F	0
is	0
empty,	0
then	0
one	0
can	0
observe	0
that	0
for	0
every	0
2-	0
0	0
simplex	0
{i,	0
j,	0
k}	0
in	0
R	0
rv	0
,	0
the	0
convex	0
hull	0
of	0
the	0
robots	0
i,	0
j	0
0	0
and	0
k	0
will	0
be	0
covered	0
by	0
the	0
disk	0
of	0
visibility	0
for	0
each	0
of	0
0	0
these	0
robots.	0
If	0
{i,	0
j}	0
is	0
a	0
1-simplex	0
in	0
O,	0
then	0
due	0
to	0
the	0
0	0
way	0
we	0
introduce	0
elements	0
in	0
O	0
(Section	0
III-A),	0
the	0
region	0
0	0
between	0
the	0
obstacle	0
1-simplices	0
and	0
the	0
actual	0
obstacles	0
0	0
themselves	0
will	0
always	0
remain	0
covered	0
by	0
some	0
robots	0
disk	0
0	0
of	0
visibility	0
(except	0
for	0
non-convex	0
features	0
on	0
the	0
side	0
of	0
the	0
0	0
obstacles	0
that	0
are	0
smaller	0
than	0
r	0
v	0
).	0
Thus,	0
when	0
F	0
is	0
empty,	0
0	0
we	0
can	0
guarantee	0
sensor	0
coverage	0
of	0
the	0
entire	0
environment.	0
0	0
Robustness	0
to	0
Robot	0
Failure:	0
The	0
proposed	0
algorithm	0
can	0
0	0
adapt	0
to	0
failure	0
of	0
robots.	0
If	0
a	0
robot	0
fails	0
(and	0
its	0
neighbors	0
0	0
can	0
detect	0
that),	0
the	0
swarm	0
will	0
ignore	0
the	0
presence	0
of	0
the	0
0	0
failed	0
robot.	0
Thus	0
a	0
hole	0
in	0
the	0
complex	0
gets	0
created,	0
and	0
0	0
hence	0
F	0
will	0
have	0
the	0
frontier	0
simplices	0
surrounding	0
that	0
0	0
hole.	0
This	0
will	0
result	0
in	0
new	0
robot(s)	0
being	0
deployed	0
to	0
the	0
0	0
newly	0
open	0
frontier,	0
until	0
F	0
becomes	0
empty	0
once	0
again.	0
0	0
Optimal	0
Coverage:	0
While	0
our	0
deployment	0
algorithm	0
itself	0
0	0
does	0
not	0
guarantee	0
optimality,	0
the	0
process	0
of	0
identifying	0
re-	0
0	0
dundant	0
robots	0
by	0
computing	0
the	0
smallest	0
non-trivial	0
relative	0
0	0
cycle	0
in	0
(R	0
rv	0
,	0
K)	0
(described	0
in	0
section	0
III-D),	0
and	0
hence	0
0	0
redistribution	0
of	0
the	0
redundant	0
robots,	0
makes	0
sure	0
that	0
we	0
0	0
do	0
not	0
use	0
more	0
roots	0
than	0
required	0
to	0
cover	0
the	0
entire	0
0	0
environment.	0
While	0
this	0
still	0
is	0
not	0
a	0
guarantee	0
of	0
global	0
0	0
optimality,	0
this	0
indeed	0
is	0
a	0
local	0
optimality	0
in	0
the	0
sense	0
that	0
0	0
after	0
redistribution	0
we	0
end	0
up	0
with	0
a	0
complex	0
that	0
is	0
the	0
0	0
optimum	0
subcomplex	0
of	0
the	0
original	0
complex	0
without	0
any	0
0	0
redundant	0
robot.	0
0	0
Limitations:	0
Since	0
the	0
robots	0
use	0
the	0
omnidirectional	0
0	0
cameras	0
only	0
to	0
obtain	0
bearing	0
to	0
neighbors,	0
and	0
the	0
only	0
0	0
way	0
they	0
sense	0
obstacles	0
is	0
through	0
direct	0
touch/contact,	0
it	0
0	0
is	0
not	0
possible	0
to	0
detect	0
features	0
that	0
are	0
smaller	0
than	0
r	0
v	0
.	0
0	0
Thus,	0
presence	0
of	0
non-convex	0
features	0
on	0
the	0
surface	0
of	0
the	0
0	0
obstacles	0
that	0
are	0
smaller	0
than	0
r	0
v	0
may	0
result	0
in	0
some	0
blind-	0
0	0
spots	0
inside	0
the	0
non-convex	0
grooves.	0
0	0
V.	0
RESULTS	0
0	0
We	0
demonstrate	0
the	0
performance	0
of	0
the	0
proposed	0
al-	0
0	0
gorithm	0
in	0
simulation	0
using	0
integrated	0
platform	0
between	0
0	0
Robot	0
Operating	0
System	0
(ROS)	0
[22],	0
Stage	0
Simulator	0
[23]	0
0	0
and	0
JavaPlex	0
[21].	0
We	0
use	0
ROS	0
as	0
a	0
backbone	0
that	0
links	0
0	0
all	0
components	0
together.	0
Stage	0
simulates	0
the	0
dynamics	0
and	0
0	0
sensors	0
of	0
the	0
robots,	0
while	0
JavaPlex	0
is	0
used	0
to	0
compute	0
the	0
0	0
relative	0
homology	0
for	0
identifying	0
the	0
redundant	0
robot.	0
0	0
A.	0
Comparison	0
with	0
Hexagonal	0
Packing	0
0	0
To	0
evaluate	0
the	0
performance	0
of	0
the	0
proposed	0
algorithms,	0
0	0
we	0
compare	0
the	0
number	0
of	0
robots	0
used	0
in	0
covering	0
an	0
0	0
obstacle-free	0
rectangular	0
region	0
using	0
our	0
algorithm	0
and	0
0	0
using	0
the	0
hexagonal	0
packing,	0
which	0
we	0
constructed	0
manually	0
0	0
by	0
overlaying	0
the	0
environment	0
on	0
a	0
hexagonal	0
packing	0
in	0
a	0
0	0
free	0
space.	0
In	0
an	0
obstacle-free	0
environment,	0
the	0
performance	0
0	0
of	0
our	0
algorithms	0
is	0
comparable	0
to	0
the	0
hexagonal	0
packing	0
0	0
solution	0
as	0
illustrated	0
in	0
Figure	0
11.	0
The	0
majority	0
of	0
the	0
0	0
3414	0
0	0
robots	0
deployed	0
by	0
our	0
algorithm	0
are	0
in	0
the	0
hexagonal	0
0	0
packing	0
arrangement.	0
However,	0
due	0
to	0
accumulated	0
errors	0
0	0
and	0
collision	0
with	0
the	0
boundary,	0
the	0
packing	0
gets	0
distorted	0
0	0
and	0
the	0
clutter	0
of	0
robots	0
is	0
higher	0
near	0
the	0
boundary.	0
0	0
(a)	0
Deployment	0
using	0
the	0
proposed	0
al-	0
0	0
gorithms	0
(robots	0
deployed	0
from	0
the	0
0	0
source	0
on	0
the	0
right).	0
0	0
(b)	0
Hexagonal	0
Packing	0
using	0
0	0
the	0
same	0
average	0
separation	0
0	0
between	0
the	0
robots,	0
rv.	0
0	0
Fig.	0
11.	0
Our	0
algorithm	0
deployed	0
98	0
robots	0
while	0
the	0
hexagonal	0
packing	0
0	0
requires	0
approximately	0
78	0
robots.	0
0	0
B.	0
Structured	0
environment	0
0	0
Our	0
algorithm	0
attains	0
a	0
similar	0
performance	0
in	0
a	0
structured	0
0	0
environment	0
with	0
few	0
obstacles	0
as	0
illustrated	0
in	0
Figure	0
12.	0
0	0
Comparison	0
between	0
figures	0
(c)	0
and	0
(d)	0
illustrates	0
that	0
the	0
0	0
performance	0
of	0
our	0
algorithm	0
is	0
comparable	0
to	0
the	0
hexagonal	0
0	0
packing.	0
We	0
present	0
more	0
results	0
in	0
cluttered	0
environments	0
0	0
in	0
the	0
video	0
accompanying	0
this	0
paper.	0
0	0
(a)	0
T	0
=	0
14	0
0	0
(b)	0
T	0
=	0
64	0
0	0
(c)	0
T	0
=	0
106	0
0	0
(d)	0
Hexagonal	0
Packing	0
0	0
Fig.	0
12.	0
Demonstration	0
in	0
a	0
structured	0
environment	0
with	0
obstacles.	0
Figures	0
0	0
(a)-(c)	0
illustrate	0
the	0
progress	0
of	0
our	0
sensor	0
coverage	0
algorithm	0
at	0
14,	0
64,	0
0	0
and	0
106	0
deployment	0
cycles	0
respectively.	0
Figure	0
(d)	0
is	0
the	0
ideal	0
hexagonal	0
0	0
packing	0
in	0
the	0
environment	0
for	0
comparison,	0
attained	0
using	0
82	0
robots	0
and	0
0	0
using	0
the	0
same	0
average	0
separation	0
between	0
the	0
robots.	0
0	0
VI.	0
DISCUSSIONS	0
0	0
In	0
this	0
paper,	0
we	0
proposed	0
an	0
algorithm	0
for	0
the	0
deploy-	0
0	0
ment	0
of	0
a	0
swarm	0
of	0
resource-constrained,	0
mobile	0
robots	0
0	0
in	0
an	0
unknown	0
environment	0
with	0
the	0
objective	0
of	0
attaining	0
0	0
complete	0
sensor	0
coverage	0
of	0
the	0
environment	0
without	0
using	0
0	0
any	0
metric	0
information.	0
The	0
only	0
sensors	0
are	0
a	0
limited	0
0	0
range	0
omnidirectional	0
camera	0
that	0
can	0
detect	0
bearing	0
to	0
0	0
neighboring	0
robots	0
and	0
a	0
touch	0
sensor	0
for	0
detecting	0
contact	0
0	0
with	0
obstacles	0
and	0
other	0
robots.	0
No	0
global	0
information	0
is	0
0	0
available.	0
The	0
proposed	0
algorithm,	0
which	0
is	0
derived	0
from	0
0	0
concepts	0
in	0
algebraic	0
topology,	0
is	0
complete,	0
terminates	0
in	0
0	0
finite	0
environments,	0
is	0
robust	0
to	0
noise	0
and	0
robot	0
failures,	0
and	0
0	0
is	0
locally	0
optimal.	0
We	0
demonstrate	0
the	0
performance	0
of	0
the	0
0	0
proposed	0
algorithm	0
through	0
a	0
C++	0
implementation	0
on	0
a	0
ROS	0
0	0
platform	0
0	0
REFERENCES	0
0	0
[1]	0
IA	0
Wagner,	0
M.	0
Lindenbaum,	0
and	0
AM.	0
Bruckstein.	0
Distributed	0
cover-	0
0	0
ing	0
by	0
ant-robots	0
using	0
evaporating	0
traces.	0
Robotics	0
and	0
Automation,	0
0	0
IEEE	0
Transactions	0
on,	0
15(5):918933,	0
Oct	0
1999.	0
0	0
[2]	0
Ercan	0
U.	0
Acar,	0
Howie	0
Choset,	0
Alfred	0
A.	0
Rizzi,	0
Prasad	0
N.	0
Atkar,	0
0	0
and	0
Douglas	0
Hull.	0
Morse	0
decompositions	0
for	0
coverage	0
tasks.	0
The	0
0	0
International	0
Journal	0
of	0
Robotics	0
Research,	0
21(4):331344,	0
2002.	0
0	0
[3]	0
Enric	0
Galceran	0
and	0
Marc	0
Carreras.	0
A	0
survey	0
on	0
coverage	0
path	0
0	0
planning	0
for	0
robotics.	0
Robotics	0
and	0
Autonomous	0
Systems,	0
61(12):1258	0
0	0
1276,	0
2013.	0
0	0
[4]	0
J.	0
Cortes,	0
S.	0
Martinez,	0
T.	0
Karatas,	0
and	0
F.	0
Bullo.	0
Coverage	0
control	0
for	0
0	0
mobile	0
sensing	0
networks.	0
IEEE	0
Trans.	0
Robot.	0
Autom.,	0
20(2):243255,	0
0	0
April	0
2004.	0
0	0
[5]	0
Subhrajit	0
Bhattacharya,	0
Robert	0
Ghrist,	0
and	0
Vijay	0
Kumar.	0
Multi-robot	0
0	0
coverage	0
and	0
exploration	0
on	0
riemannian	0
manifolds	0
with	0
boundary.	0
0	0
International	0
Journal	0
of	0
Robotics	0
Research,	0
33(1):113137,	0
January	0
0	0
2014.	0
DOI:	0
10.1177/0278364913507324.	0
0	0
[6]	0
Samuel	0
Rutishauser,	0
Nikolaus	0
Correll,	0
and	0
Alcherio	0
Martinoli.	0
Col-	0
0	0
laborative	0
coverage	0
using	0
a	0
swarm	0
of	0
networked	0
miniature	0
robots.	0
0	0
Robotics	0
and	0
Autonomous	0
Systems,	0
57(5):517	0
525,	0
2009.	0
0	0
[7]	0
G.	0
Dudek,	0
M.	0
Jenkin,	0
E.	0
Milios,	0
and	0
D.	0
Wilkes.	0
Robotic	0
exploration	0
0	0
as	0
graph	0
construction.	0
Robotics	0
and	0
Automation,	0
IEEE	0
Transactions	0
0	0
on,	0
7(6):859865,	0
Dec	0
1991.	0
0	0
[8]	0
Sven	0
Koenig,	0
Boleslaw	0
Szymanski,	0
and	0
Yaxin	0
Liu.	0
Efficient	0
and	0
0	0
inefficient	0
ant	0
coverage	0
methods.	0
Annals	0
of	0
Mathematics	0
and	0
Artificial	0
0	0
Intelligence,	0
31(1-4):4176,	0
2001.	0
0	0
[9]	0
Michael	0
Rubenstein,	0
Alejandro	0
Cornejo,	0
and	0
Radhika	0
Nagpal.	0
Pro-	0
0	0
grammable	0
self-assembly	0
in	0
a	0
thousand-robot	0
swarm.	0
0	0
Science,	0
0	0
345(6198):795799,	0
2014.	0
0	0
[10]	0
Maxim	0
Batalin	0
and	0
Gaurav	0
S.	0
Sukhatme.	0
The	0
design	0
and	0
analysis	0
of	0
an	0
0	0
efficient	0
local	0
algorithm	0
for	0
coverage	0
and	0
exploration	0
based	0
on	0
sensor	0
0	0
network	0
deployment.	0
IEEE	0
Transactions	0
on	0
Robotics,	0
23(4):661675,	0
0	0
Aug	0
2007.	0
0	0
[11]	0
V.	0
de	0
Silva	0
and	0
R.	0
Ghrist.	0
Coordinate-free	0
coverage	0
in	0
sensor	0
networks	0
0	0
with	0
controlled	0
boundaries	0
via	0
homology.	0
The	0
International	0
Journal	0
0	0
of	0
Robotics	0
Research,	0
25(12):12051222,	0
2006.	0
0	0
[12]	0
R.	0
Ghrist,	0
D.	0
Lipsky,	0
J.	0
Derenick,	0
and	0
A.	0
Speranzon.	0
Topological	0
0	0
landmark-based	0
navigation	0
and	0
mapping,	0
2012.	0
0	0
[13]	0
Jason	0
Derenick,	0
Vijay	0
Kumar,	0
and	0
Ali	0
Jadbabaie.	0
Towards	0
simplicial	0
0	0
coverage	0
repair	0
for	0
mobile	0
robot	0
teams.	0
In	0
Robotics	0
and	0
Automation	0
0	0
(ICRA),	0
2010	0
IEEE	0
International	0
Conference	0
on,	0
pages	0
54725477.	0
0	0
IEEE,	0
2010.	0
0	0
[14]	0
A.	0
Muhammad	0
and	0
M.	0
Egerstedt.	0
Control	0
using	0
higher	0
order	0
lapla	0
0	0
cians	0
in	0
network	0
topologies.	0
In	0
Proceedings	0
of	0
the	0
17th	0
International	0
0	0
Symposium	0
on	0
Mathematical	0
Theory	0
of	0
Networks	0
and	0
Systems,	0
pages	0
0	0
10241038,	0
Kyoto,	0
Japan,	0
2006.	0
0	0
[15]	0
Josep	0
Aulinas,	0
Yvan	0
Petillot,	0
Joaquim	0
Salvi,	0
and	0
Xavier	0
Llad	0
o.	0
The	0
0	0
slam	0
problem:	0
A	0
survey.	0
In	0
Proceedings	0
of	0
the	0
2008	0
Conference	0
0	0
on	0
Artificial	0
Intelligence	0
Research	0
and	0
Development:	0
Proceedings	0
of	0
0	0
the	0
11th	0
International	0
Conference	0
of	0
the	0
Catalan	0
Association	0
for	0
0	0
Artificial	0
Intelligence,	0
pages	0
363371,	0
Amsterdam,	0
The	0
Netherlands,	0
0	0
The	0
Netherlands,	0
2008.	0
IOS	0
Press.	0
0	0
[16]	0
SeoungKyou	0
Lee,	0
Aaron	0
Becker,	0
S	0
andor	0
P.	0
Fekete,	0
Alexander	0
Kr	0
oller,	0
0	0
and	0
James	0
McLurkin.	0
Exploration	0
via	0
structured	0
triangulation	0
by	0
a	0
0	0
multi-robot	0
system	0
with	0
bearing-only	0
low-resolution	0
sensors.	0
CoRR,	0
0	0
abs/1402.0400,	0
2014.	0
0	0
[17]	0
Allen	0
Hatcher.	0
Algebraic	0
Topology.	0
Cambridge	0
Univ.	0
Press,	0
2001.	0
0	0
[18]	0
R.	0
Tron	0
and	0
K.	0
Daniilidis.	0
Technical	0
report	0
on	0
Optimization-Based	0
0	0
Bearing-Only	0
Visual	0
Homing	0
with	0
Applications	0
to	0
a	0
2-D	0
Unicycle	0
0	0
Model.	0
ArXiv	0
e-prints,	0
February	0
2014.	0
0	0
[19]	0
H.-C.	0
Chang	0
and	0
L.-C.	0
Wang.	0
A	0
Simple	0
Proof	0
of	0
Thues	0
Theorem	0
on	0
0	0
Circle	0
Packing.	0
ArXiv	0
e-prints,	0
September	0
2010.	0
0	0
[20]	0
M.	0
Sghaier,	0
H.	0
Zgaya,	0
S.	0
Hammadi,	0
and	0
C.	0
Tahon.	0
A	0
distributed	0
0	0
dijkstras	0
algorithm	0
for	0
the	0
implementation	0
of	0
a	0
real	0
time	0
carpooling	0
0	0
service	0
with	0
an	0
optimized	0
aspect	0
on	0
siblings.	0
In	0
Intelligent	0
Trans-	0
0	0
portation	0
Systems	0
(ITSC),	0
2010	0
13th	0
International	0
IEEE	0
Conference	0
0	0
on,	0
pages	0
795800,	0
Sept	0
2010.	0
0	0
[21]	0
Andrew	0
Tausz,	0
Mikael	0
Vejdemo-Johansson,	0
and	0
Henry	0
Adams.	0
0	0
Javaplex:	0
A	0
research	0
software	0
package	0
for	0
persistent	0
(co)homology.	0
0	0
Software,	0
2011.	0
0	0
[22]	0
M.	0
Quigley,	0
B.	0
Gerkey,	0
K.	0
Conley,	0
J.	0
Faust,	0
T.	0
Foote,	0
J.	0
Leibs,	0
0	0
E.	0
Berger,	0
R.	0
Wheeler,	0
and	0
A.	0
Ng.	0
ROS:	0
an	0
open-source	0
robot	0
0	0
operating	0
system.	0
In	0
Proc.	0
of	0
the	0
IEEE	0
Intl.	0
Conf.	0
on	0
Robot.	0
and	0
0	0
Autom.,	0
Kobe,	0
Japan,	0
May	0
2009.	0
0	0
[23]	0
The	0
stage	0
robot	0
simulator.	0
http://rtv.github.io/Stage/.	1
0	0
3415	0
0	0
